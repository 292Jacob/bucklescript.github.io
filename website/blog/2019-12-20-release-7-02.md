---
title: BuckleScript holiday release!
---

[bs-platform@7.0.2-dev.1](https://github.com/BuckleScript/bucklescript/pull/4062) is released for testing!

Try it via

```
npm i -g bs-platform@7.0.2-dev.1
```

This release contains several bug fixes for refmt(the reason parser), we also spend quite some time improving compiler performance, for example, we optimized all our vendored type specialized hash based data structures, it is expected to have around 5% build performance enhancement, and we would like to collect your data points and have your feedback.

A highlighting feature is that we support a generalized unboxed support:

```
unboxed can be used on a type definition if the type is a single-field record or a concrete type with a single constructor that has a single argument. It tells the compiler to optimize the representation of the type by removing the block that represents the record or the constructor (i.e. a value of this type is physically equal to its argument). In the case of GADTs, an additional restriction applies: the argument must not be an existential variable, represented by an existential type variable, or an abstract type constructor applied to an existential type variable.
```

The great thing is such restriction is only in native backend but does not apply to BuckleScript so it is generally more useful and will not give your confusing error message.


The cool thing is that it not only provides your some optimizations but makes something impossible before now possible. A sophiscated explanation is listed in the end (feel free to ignore the paragraph below if you d)


Take this for example:

```reason
[@unboxed]
type t = 
  | Any ('a) ; 
```

```ocaml
type t = 
  | Any : 'a -> t
[@@unboxed]
```

With unboxed annotation, user can erase the types with zero cost:

```reason
let array = [|Any(3), Any("a")|];
```

```ocaml
let array = [|Any 3; Any "a"|]
```

The generated code is as follows:
```js
var array = [ 3, "a" ];
```
By making use of OCaml's powerful module system, user can define user level's `int_or_string` type.

Another use case is achieving high rank polymorphism without cost

```ocaml
type r = { f : 'a . ('a -> 'a ) } [@@unboxed]
let map_pair r (p1, p2) = (r.f p1, r.f p2)
```

```reason
[@unboxed]
type r = {f: 'a. 'a => 'a};
let map_pair = (r, (p1, p2)) => (r.f(p1), r.f(p2));
```

By making use of this,  we will get rid of [value restriction for our existing encoding of uncurried function](https://github.com/BuckleScript/bucklescript/issues/4058), this will be a major feature!

A detailed list of changes is available here: https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702



# A sophiscated explanation on why `unboxed` lift some OCaml's type system limitations

structural
types (objects, classes, polymorphic variants, functions, etc) in OCaml are regular types, ocaml always do the expansion when dealing with such types, there is some limitations for such structural types, for example, non regular definitions are not allowed. Non structural types (variants, records) does not have such limitations, with `unboxed`, we can use non structural types as an indirection without changing its runtime representations.

