<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Object · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Object · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/index.html"/><meta property="og:description" content="Les objets en JavaScript ont tellement d&#x27;usages différents que s&#x27;il nous devions avoir une seule API pour les typer tous, nous finirions probablement avec &quot;cet un objet qui a potentiellement plusieurs champs inconnus avec plusieurs types de valeurs inconnues&quot;, ce qui ne serait pas très utile."/><link rel="shortcut icon" href="/img/logos/bucklescript_small.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logos/bucklescript_small.svg"/><h2 class="headerTitle">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/installation.html" target="_self">Docs</a></li><li><a href="/docs/fr/playground.html" target="_self">Try</a></li><li><a href="/docs/fr/stdlib-overview.html" target="_self">API</a></li><li><a href="/docs/fr/community.html" target="_self">Community</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Interop</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-why.html">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/installation.html">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/new-project.html">New Project</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/concepts-overview.html">Vue d’Ensemble des Concepts</a></li></ul></div><div class="navGroup navGroupActive"><h3>Interop</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/interop-overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop-cheatsheet.html">Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/embed-raw-javascript.html">Embed Raw JavaScript</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/common-data-types.html">Types de données communs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/intro-to-external.html">Intro to External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/bind-to-global-values.html">Bind to Global Values</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option.html">Null, Undefined &amp; Option</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/object.html">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/class.html">Class</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function.html">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/import-export.html">Import &amp; Export</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/regular-expression.html">Regular Expression</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exceptions.html">Exceptions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/json.html">JSON</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/generate-converters-accessors.html">Generate Converters &amp; Helpers</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/nodejs-special-variables.html">NodeJS Special Variables</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop-misc.html">Miscellaneous</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/typescript-support.html">TypeScript Support</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/browser-support-polyfills.html">Support navigateur et Polyfills</a></li></ul></div><div class="navGroup navGroupActive"><h3>Build System</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/build-overview.html">Vue d&#x27;ensemble</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-configuration.html">Configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/automatic-interface-generation.html">Automatic Interface Generation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop-with-js-build-systems.html">Interop with JS Build System</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-performance.html">Performance</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-advanced.html">Advanced</a></li></ul></div><div class="navGroup navGroupActive"><h3>Standard Library</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/stdlib-overview.html">Overview</a></li></ul></div><div class="navGroup navGroupActive"><h3>Advanced</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/conditional-compilation.html">Compilation Conditionnelle</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extended-compiler-options.html">Extended Compiler Options</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/use-existing-ocaml-libraries.html">Use Existing OCaml Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/difference-from-native-ocaml.html">Différence avec OCaml Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/compiler-architecture-principles.html">Architecture du Compilateur &amp; Principes</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-jsoo.html">Comparison to Js_of_ocaml</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/fr" target="_blank">Translate</a><h1>Object</h1></header><article><div><span><p>Les objets en JavaScript ont tellement d'usages différents que s'il nous devions avoir une seule API pour les typer tous, nous finirions probablement avec &quot;cet un objet qui a potentiellement plusieurs champs inconnus avec plusieurs types de valeurs inconnues&quot;, ce qui ne serait pas très utile.</p>
<p>BS sépare les différents usages des objets JS en différentes catégories, pour une meilleure UX et de meilleures perfs.</p>
<h2><a class="anchor" aria-hidden="true" name="objet-en-tant-que-hash-map"></a><a href="#objet-en-tant-que-hash-map" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Objet en tant que Hash Map</h2>
<p>Jusqu'à récemment, ou le support de vraies Map a été introduit en JS, les objets ont été utilisés en tant que map. Les caractéristiques des objets en tant que map sont les suivantes:</p>
<ul>
<li>contient des valeurs de même type</li>
<li>propose l'ajout/retrait de clés arbitraires</li>
<li>propose un accès à ses éléments par clés dynamiques/calculées</li>
</ul>
<p>If these points (especially the first one) describe your object usage, then look no further than using the <a href="https://bucklescript.github.io/bucklescript/api/Js.Dict.html"><code>Js.Dict</code></a> API! This is a thin wrapper we've made for such situation. Techniquement, un <code>Js.Dict</code> est seulement un objet, et toute son API est détruite après la compilation. Il n'y a aucun impact sur les performances. En fait elles sont mêmes <strong>meilleures</strong> ! See the Design Decisions below.</p>
<p>Dans ce mode, vous pouvez faire de la meta-programmation de la même façon qu'avec des objets JS: récupérer toutes les clés via <code>Js.Dict.keys</code>, récupérer les valeurs grâce à <code>Js.Dict.values</code>, etc.</p>
<h3><a class="anchor" aria-hidden="true" name="exemple"></a><a href="#exemple" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exemple</h3>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> myMap = <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.empty <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> _ = <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.set myMap <span class="hljs-string">"Allison"</span> <span class="hljs-number">10</span>
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> myMap = Js.<span class="hljs-built_in">Dict</span>.empty();
Js.<span class="hljs-built_in">Dict</span>.set(myMap, <span class="hljs-string">"Allison"</span>, <span class="hljs-number">10</span>);
</code></pre>
<p>Sortie:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> myMap = { };
myMap[<span class="hljs-string">"Allison"</span>] = <span class="hljs-number">10</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="objet-en-tant-que-record"></a><a href="#objet-en-tant-que-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Objet en tant que « Record »</h2>
<p>Si votre objet :</p>
<ul>
<li>a un nombre connu de champs</li>
<li>peut contenir des valeurs de différents types</li>
</ul>
<p>Dans ce cas vous semblez utiliser ce qu'on appelle un « record » dans la plupart des langages. Par exemple, pensez à la différence de cas d’utilisation et d’intention entre l'objet <code>{name: &quot;John&quot;, age: 10, job: &quot;CEO&quot;}</code> et <code>{&quot;John&quot;: 10, &quot;Allison&quot;: 20, &quot;Jimmy&quot;: 15}</code>.</p>
<p>Le dernier cas serait « le mode hash map » tandis que le premier serait le « mode record ».</p>
<h3><a class="anchor" aria-hidden="true" name="typage"></a><a href="#typage" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typage</h3>
<p>Utilisez le type <code>Js.t</code> qui encapsule un type d’objet OCaml :</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>
&gt; <span class="hljs-type">Js</span>.t

<span class="hljs-keyword">external</span> john : person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason">type person = <span class="hljs-keyword">Js.t({
</span>  .
<span class="hljs-symbol">  name:</span> string,
<span class="hljs-symbol">  age:</span> int,
<span class="hljs-symbol">  job:</span> string
})<span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>Désormais</strong>, nous appellerons l'objet d'interopérabilité BuckleScript « <code>Js.t</code> », pour éviter les ambiguïtés avec l'objet JS traditionnel.</p>
<p>Comme les types d'objets sont utilisés souvent, Reason offre un sucre syntaxique. <code>Js.t({. name: string})</code> peut s'écrire <code>{. &quot;name&quot;: string}</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="accesseurs"></a><a href="#accesseurs" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accesseurs</h3>
<h4><a class="anchor" aria-hidden="true" name="lecture"></a><a href="#lecture" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lecture</h4>
<p>Pour accéder à un champ, utilisez <code>##</code>: <code>let johnName = john##name</code>.</p>
<h4><a class="anchor" aria-hidden="true" name="ecriture"></a><a href="#ecriture" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Écriture</h4>
<p>Pour modifier un champs, vous devez d'abord déclarer ce champs comme mutable. Par défaut, le type d'objet <code>Js.t</code> est immutable.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; age : <span class="hljs-built_in">int</span> [@bs.set] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##age #= <span class="hljs-number">99</span>
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason">type person = {. [@<span class="hljs-keyword">bs.set] </span><span class="hljs-string">"age"</span>: int}<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>

<span class="hljs-keyword">john##age </span><span class="hljs-comment">#= 99;</span>
</code></pre>
<p><strong>Note</strong>: vous ne pouvez utiliser de propriétés dynamiques/calculées avec ce paradigme.</p>
<h4><a class="anchor" aria-hidden="true" name="appel"></a><a href="#appel" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appel</h4>
<p>To call a method of a field, mark the function signature as <code>[@bs.meth]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; say : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> [@bs.meth] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##say <span class="hljs-string">"hey"</span> <span class="hljs-string">"jude"</span>
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> person = {. [@bs.meth] <span class="hljs-string">"say"</span>: <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>)</span> =&gt;</span> unit};
[@bs.val] external john : person = <span class="hljs-string">"john"</span>;

john##say(<span class="hljs-string">"hey"</span>, <span class="hljs-string">"jude"</span>);
</code></pre>
<p><strong>Pourquoi <code>[bs.meth]</code></strong> ? Pourquoi ne pas juste appeler la méthode directement ? Un objet en JS doit prendre en compte la référence <code>this</code>, et malheureusement, ce sur quoi <code>this</code> pointe peut changer. OCaml/BuckleScript functions are curried by default; this means that if you intentionally curry <code>say</code>, by the time you fully apply it, the <code>this</code> context could be wrong:</p>
<pre><code class="hljs css ocaml"><span class="hljs-comment">(* wrong *)</span>
<span class="hljs-keyword">let</span> talkTo = john##say(<span class="hljs-string">"hey"</span>)

<span class="hljs-keyword">let</span> jude = talkTo <span class="hljs-string">"jude"</span>
<span class="hljs-keyword">let</span> paul = talkTo <span class="hljs-string">"paul"</span>
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* wrong */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">talkTo</span> = john<span class="hljs-comment">##say("hey");</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">jude</span> = talkTo(<span class="hljs-string">"jude"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-attr">paul</span> = talkTo(<span class="hljs-string">"paul"</span>);
</code></pre>
<p>To ensure that folks don't accidentally curry a JavaScript method, we track every method call using <code>##</code> to make sure it's fully applied <em>immediately</em>. Under the hood, we effectively turn a function-looking call into a special <code>bs.meth</code> call (it only <em>looks</em> like a function). Annotating the type definition of <code>say</code> with <code>bs.meth</code> completes this check.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>Vous pouvez utiliser <code>[%bs.obj putAnOCamlRecordHere]</code> pour créer un objet JS :</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info = {author = <span class="hljs-string">"Bob"</span>}
}]

<span class="hljs-keyword">let</span> name = bucklescript##info##author
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info: {author: <span class="hljs-string">"Bob"</span>}
}];

<span class="hljs-keyword">let</span> name = bucklescript##info##author;
</code></pre>
<p>Du fait que les objets soient souvent utilisés, Reason offre un sucre syntaxique. <code>[%bs.obj {foo: 1}]</code> qui se transforme en <code>{&quot;foo&quot;: 1}</code>.</p>
<p><strong>Note</strong>: il n’y a aucun sucre syntaxique pour la création d’un objet vide en OCaml ni Reason (ceci ne fonctionne pas : <code>[@bs.obj {}]</code>). Vous pouvez en revanche utiliser <code>Js.Obj.empty()</code>.</p>
<p>Le type de l'objet sera inféré, aucune déclaration de type n'est donc nécessaire ! Dans l'exemple suivant l'objet sera inféré tel que: <code>&lt; info: &lt; author: string &gt; Js.t &gt; Js.t</code>. En Reason: <code>{. &quot;info&quot;: {. &quot;author&quot;: string}}</code>.</p>
<p><strong>Note</strong>: comme la valeur a son type inféré, <strong>n'écrivez pas</strong>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;age: <span class="hljs-built_in">int</span>&gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">let</span> jane = [%bs.obj {age = <span class="hljs-string">"hi"</span>}]
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">type person</span> = {. <span class="hljs-string">"age"</span>: int};
<span class="hljs-attribute">let jane</span> = {<span class="hljs-string">"age"</span>: <span class="hljs-string">"hi"</span>};
</code></pre>
<p>Vous voyez le problème ? Nous avons créé un type <code>person</code>, mais le celui de <code>jane</code> est inféré automatiquement. Le type <code>person</code> sera ignoré sans qu'aucune erreur ne soit levée ! Pour donner à <code>jane</code> un type explicite, annotez le: <code>let jane: person = ...</code>. Dans ce cas, une erreur sera levée.</p>
<h4><a class="anchor" aria-hidden="true" name="cas-particulier-du-constructeur"></a><a href="#cas-particulier-du-constructeur" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cas particulier du constructeur</h4>
<p>Les paramètres nommés des fonctions OCaml se prêtent plutôt bien à la création d'objet JS. Nous offrons un autre moyen de créer des objets, <code>bs.obj</code>, pratique si l'objet contient des champs optionnels:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeConfig : high:<span class="hljs-built_in">int</span> -&gt; ?low:<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> -&gt; _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> c1 = makeConfig ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> c2 = makeConfig ~low:<span class="hljs-number">2</span> ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>

<span class="hljs-comment">(* access them as Js.t objects! *)</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-built_in">int</span> = c1##high
<span class="hljs-keyword">let</span> low: <span class="hljs-built_in">int</span> <span class="hljs-type">Js</span>.undefined = c1##low
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason">[@bs.obj] external makeConfig : (~high: int, ~low: <span class="hljs-attr">int=?,</span> unit) =&gt; <span class="hljs-attr">_</span> = <span class="hljs-string">""</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">c1</span> = makeConfig(~<span class="hljs-attr">high=3,</span> ());
<span class="hljs-keyword">let</span> <span class="hljs-attr">c2</span> = makeConfig(~<span class="hljs-attr">low=2,</span> ~<span class="hljs-attr">high=3,</span> ());

<span class="hljs-comment">/* access them as Js.t objects! */</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-attr">int</span> = c1<span class="hljs-comment">##high;</span>
<span class="hljs-keyword">let</span> low: Js.undefined(int) = c1<span class="hljs-comment">##low;</span>
</code></pre>
<p>Sortie:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> c1 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>};
<span class="hljs-keyword">var</span> c2 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">low</span>: <span class="hljs-number">2</span>};
<span class="hljs-keyword">var</span> high = c1.high;
<span class="hljs-keyword">var</span> low = c1.low;
</code></pre>
<p><strong>Note</strong>:</p>
<ul>
<li><p>La valeur de retour marquée comme <code>_</code> sera inférée en objet <code>Js.t</code> avec la forme attendue !</p></li>
<li><p>Le <code>unit</code> final est là pour indiquer que vous fini d'appliquer des arguments optionnels. Plus d'infos <a href="https://reasonml.github.io/docs/en/function.html#labeled-arguments">ici</a>.</p></li>
</ul>
<p>Vous pouvez également attacher des données statiques à un objet en utilisant <code>[@bs.as]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeIOConfig :
  stdio:(_ [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"inherit"</span>]) -&gt;
  cwd:<span class="hljs-built_in">string</span> -&gt;
  detached:(_ [@bs.<span class="hljs-keyword">as</span> {json|<span class="hljs-literal">true</span>|json}]) -&gt;
  <span class="hljs-built_in">unit</span> -&gt;
  _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> config = makeIOConfig ~cwd:<span class="hljs-string">"."</span> <span class="hljs-literal">()</span>
</code></pre>
<p>En Reason:</p>
<pre><code class="hljs css reason">[@bs.obj]
external makeIOConfig : (
  ~stdio: [@bs.as <span class="hljs-string">"inherit"</span>] _,
  ~cwd: string,
  ~detached: [@bs.as {json|<span class="hljs-literal">true</span>|json}] _,
  unit
) =&gt; _ = <span class="hljs-string">""</span>;

let<span class="hljs-built_in"> config </span>= makeIOConfig(~<span class="hljs-attribute">cwd</span>=<span class="hljs-string">"."</span>, ());
</code></pre>
<p>Sortie:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-attr">stdio</span>: <span class="hljs-string">"inherit"</span>,
  <span class="hljs-attr">cwd</span>: <span class="hljs-string">"."</span>,
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">true</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="name-mangling"></a><a href="#name-mangling" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Name mangling</h3>
<h4><a class="anchor" aria-hidden="true" name="invalid-field-names"></a><a href="#invalid-field-names" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid field names</h4>
<p>Sometimes, you might encounter JavaScript object fields that start with capital letters or use reserved words. The latter is invalid and the former is reserved for module and variant names. To circumvent this, we support object label mangling/translation:</p>
<pre><code class="hljs css ocaml">stream##_open
stream##_MAX_LENGTH
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">stream.open;
stream.MAX_LENGTH;
</code></pre>
<p><strong>Double check your JS output</strong> to make sure your name mangling worked.</p>
<p><strong>If your key contains hyphens</strong>, you'll have to use it as a dynamic record, described later.</p>
<h4><a class="anchor" aria-hidden="true" name="ad-hoc-polymorphism"></a><a href="#ad-hoc-polymorphism" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ad-hoc Polymorphism</h4>
<p>Another form of name mangling is also supported, where a double underscore (<code>__</code>) can be used add a disambiguating identifier which will be removed in the generated JS.</p>
<pre><code class="hljs css ocaml">f##draw__int <span class="hljs-number">3</span> <span class="hljs-number">4</span>
f##draw__float <span class="hljs-number">3.2</span> <span class="hljs-number">4.5</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">f<span class="hljs-function"><span class="hljs-keyword">##</span><span class="hljs-title">draw__int</span><span class="hljs-params">(3, 4)</span></span>;
f<span class="hljs-function"><span class="hljs-keyword">##</span><span class="hljs-title">draw__float</span><span class="hljs-params">(3.2, 4.5)</span></span>;
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">f.draw(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
f.draw(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.5</span>);
</code></pre>
<p>This can be useful in rare circumstances, but is generally not recommended since it produces non-idiomatic identifiers and is not very intuitive. Prefer instead to implement the object as a dynamic record (described below), or define an abstract untagged union type to encapsulate values of either type before passing them to or from JavaScript.</p>
<h3><a class="anchor" aria-hidden="true" name="js-object-ocaml-record-conversion"></a><a href="#js-object-ocaml-record-conversion" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Js Object &lt;-&gt; OCaml Record conversion</h3>
<p>If you don't want to work with <code>Js.t</code> objects and want to use idiomatic OCaml/Reason records, we provide automatic generation of helpers that convert between a <code>Js.t</code> object and a corresponding record type. See the section on <a href="/docs/fr/generate-converters-accessors.html">Generate Converters &amp; Helpers</a>.</p>
<!-- TODO: playground link -->
<h2><a class="anchor" aria-hidden="true" name="object-as-dynamic-record"></a><a href="#object-as-dynamic-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as Dynamic Record</h2>
<p>When The two above modes of talking to JS objects fail, you can always fall back to this one. And sometimes this the <strong>preferable</strong> way of talking to JS objects, because it:</p>
<ul>
<li>deals with objects with potentially arbitrary shapes</li>
<li>allows heterogeneous values</li>
<li><strong>allows hyphen and other symbols in object keys</strong></li>
</ul>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> t
<span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> -&gt; t = <span class="hljs-string">"Int32Array"</span> [@@bs.<span class="hljs-keyword">new</span>] <span class="hljs-comment">(* bs.new is documented in the class section *)</span>
<span class="hljs-keyword">external</span> get : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span> [@@bs.get_index]
<span class="hljs-keyword">external</span> set : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span> [@@bs.set_index]

<span class="hljs-keyword">let</span> i32arr = (create <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> _ = set i32arr <span class="hljs-number">0</span> <span class="hljs-number">42</span>
<span class="hljs-keyword">let</span> _ = <span class="hljs-type">Js</span>.log (get i32arr <span class="hljs-number">0</span>)
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type t;
[<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">new</span>] <span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> =&gt; t = <span class="hljs-string">"Int32Array"</span>; <span class="hljs-comment">/* bs.new is documented in the class section */</span>
[<span class="hljs-meta">@bs</span>.get_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">get</span> : (t, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span>;
[<span class="hljs-meta">@bs</span>.set_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">set</span> : (t, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; unit = <span class="hljs-string">""</span>;

let i32arr = create(<span class="hljs-number">3</span>);
<span class="hljs-keyword">set</span>(i32arr, <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);
Js.log(<span class="hljs-keyword">get</span>(i32arr, <span class="hljs-number">0</span>));
</code></pre>
<p>Albeit the names are called <code>get_index</code> and <code>set_index</code>, it's really dynamic access of objects fields and/or arrays.</p>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> i32arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(<span class="hljs-number">3</span>);
i32arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;
<span class="hljs-built_in">console</span>.log(i32arr[<span class="hljs-number">0</span>]);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="specific-getter-setter"></a><a href="#specific-getter-setter" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specific Getter/Setter</h3>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> textarea
<span class="hljs-keyword">external</span> setName : textarea -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"name"</span> [@@bs.set]
<span class="hljs-keyword">external</span> getName : textarea -&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">"name"</span> [@@bs.get]

<span class="hljs-keyword">external</span> myTextArea: textarea = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">let</span> _ = setName myTextArea <span class="hljs-string">"asd"</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type textarea<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.set] </span><span class="hljs-keyword">external </span>setName : (textarea, string) =&gt; unit = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.get] </span><span class="hljs-keyword">external </span>getName : textarea =&gt; string = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span>myTextArea : textarea = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
setName(myTextArea, <span class="hljs-string">"asd"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">myTextArea.name = <span class="hljs-string">"asd"</span>;
</code></pre>
<p>There's also a trick with object methods and method chaining in the next function section.</p>
<h2><a class="anchor" aria-hidden="true" name="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>All these tricks to bind to JS objects might be overwhelming; don't worry, you can just pick whatever you need as you go. But hopefully you can see that there's almost always a way to bind to your favorite JS library with no cost!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="null-undefined-option.html">← Null, Undefined &amp; Option</a><a class="docs-next button" href="class.html">Class →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react'
              });
            </script></body></html>