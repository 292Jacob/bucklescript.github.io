<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Función · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Función · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/index.html"/><meta property="og:description" content="La vinculación a funciones JS es como unir valores normales:"/><link rel="shortcut icon" href="/img/logos/bucklescript_small.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logos/bucklescript_small.svg"/><h2 class="headerTitle">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/es-ES/installation.html" target="_self">Documentación</a></li><li><a href="/docs/es-ES/playground.html" target="_self">Try</a></li><li><a href="/docs/es-ES/community.html" target="_self">Comunidad</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Interop</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/what-why.html">Qué y para qué</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/installation.html">Instalación</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/new-project.html">Nuevo proyecto</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/concepts-overview.html">Resumen de conceptos</a></li></ul></div><div class="navGroup navGroupActive"><h3>Interop</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop-overview.html">Resumen</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop-cheatsheet.html">Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/embed-raw-javascript.html">Insertar JavaScript crudo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/common-data-types.html">Tipos de datos comunes</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/intro-to-external.html">Intro to External</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/boolean.html">Booleano</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/bind-to-global-values.html">Enlazar a valores globales</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/null-undefined-option.html">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/class.html">Clase</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/es-ES/function.html">Función</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/import-export.html">Importar y Exportar</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/regular-expression.html">Expresión regular</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/exceptions.html">Excepciones</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/json.html">JSON</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/generate-converters-accessors.html">Generar convertidores y ayudantes</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/nodejs-special-variables.html">Variables especiales de NodeJS</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop-misc.html">Varios</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/typescript-support.html">Soporta TypeScript</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/browser-support-polyfills.html">Compatibilidad con navegadores y Polyfills</a></li></ul></div><div class="navGroup navGroupActive"><h3>Build System</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/build-overview.html">Introducción</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/build-configuration.html">Configuración</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/automatic-interface-generation.html">Generación automática de la interfaz</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop-with-js-build-systems.html">Interoperabilidad con el sistema de compilación de JS</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/build-performance.html">Rendimiento</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/build-advanced.html">Avanzado</a></li></ul></div><div class="navGroup navGroupActive"><h3>Standard Library</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/stdlib-overview.html">Resumen</a></li></ul></div><div class="navGroup navGroupActive"><h3>Advanced</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/conditional-compilation.html">Compilación condicional</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/extended-compiler-options.html">Opciones del compilador extendido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/use-existing-ocaml-libraries.html">Utilizar las bibliotecas existentes de OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/difference-from-native-ocaml.html">Difference from Native OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/compiler-architecture-principles.html">Arquitectura de compilador y principios</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/comparison-to-jsoo.html">Comparación a Js_of_ocaml</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/es-ES" target="_blank">Translate</a><h1>Función</h1></header><article><div><span><p>La vinculación a funciones JS es como unir valores normales:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> encodeURI: <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">"encodeURI"</span> [@@ bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">let</span> result = encodeURI <span class="hljs-string">"hello"</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[<span class="hljs-meta">@bs</span>.val] external <span class="hljs-built_in">encodeURI</span> : <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">"encodeURI"</span>; <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">"hola"</span>);
</code></pre>
<p>Tambien exponemos unos cuantos carácteres especiales, descritos abajo.</p>
<h2><a class="anchor" aria-hidden="true" name="argumentos-etiquetados"></a><a href="#argumentos-etiquetados" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Argumentos etiquetados</h2>
<p>OCaml tiene argumentos etiquetados (que son opcionales potencialmente). ¡Este trabajo funciona también en un <code>externo</code>tambien! Los usarás para <em>arreglar</em> el uso poco claro de una función JS. Suponiendo que estamos vinculados a esto:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">x, y, border</span>) </span>{
   <span class="hljs-comment">/* border is optional, defaults to false */</span>
}
draw(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
draw(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>)
</code></pre>
<p>Sería bueno si en el lado de BS, pudiéramos enlazar &amp; llamar <code>draw</code> mientras etiquetamos las cosas un poco:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> draw : x:<span class="hljs-built_in">int</span> -&gt; y:<span class="hljs-built_in">int</span> -&gt; ?border:<span class="hljs-type">Js</span>.boolean -&gt; <span class="hljs-built_in">unit</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = draw ~x:<span class="hljs-number">10</span> ~y:<span class="hljs-number">20</span> ~border:<span class="hljs-type">Js</span>.true_ <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> _ = draw ~x:<span class="hljs-number">10</span> ~y:<span class="hljs-number">20</span> <span class="hljs-literal">()</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.val] external draw: (~x:int, ~y:int, ~border:Js.<span class="hljs-attribute">boolean</span>=?, unit) =&gt; unit = <span class="hljs-string">""</span>;

draw(~<span class="hljs-attribute">x</span>=10, ~<span class="hljs-attribute">y</span>=20, ~<span class="hljs-attribute">border</span>=Js.true_, ());
draw(~<span class="hljs-attribute">x</span>=10, ~<span class="hljs-attribute">y</span>=20, ());
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js">draw(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>);
draw(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">undefined</span>);
</code></pre>
<p>Hemos compilado a la misma función, ¡pero ahora el uso es mucho más claro en el lado BS gracias a las etiquetas!</p>
<p><strong>Nota</strong>: en este caso particular, necesitar una unidad <code>()</code> después de <code>border</code>, ya que <code>border</code> es un <a href="https://reasonml.github.io/docs/en/function.html#optional-labeled-arguments">argumento opcional de última posición</a>. No tener una unidad indica que terminaste de aplicar la función y generaría una advertencia.</p>
<h2><a class="anchor" aria-hidden="true" name="metodo-de-objeto"></a><a href="#metodo-de-objeto" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Método de Objeto</h2>
<p>Pudiste haber visto en el objeto y registrado la sección a la que quieres adjuntar un <code>bs.meth</code> en un objeto <code>Js.t</code> y llamarlo como un método. Esta sección presenta un uso alternativo de <code>bs.send</code>.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> document <span class="hljs-comment">(* abstract type for a document object *)</span>
<span class="hljs-keyword">external</span> getElementById : document -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-type">Dom</span>.element = <span class="hljs-string">"getElementById"</span> [@@bs.send]
<span class="hljs-keyword">external</span> doc: document = <span class="hljs-string">"document"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> el = getElementById doc <span class="hljs-string">"myId"</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-built_in">document</span>; <span class="hljs-comment">/* abstract type for a document object */</span>
[<span class="hljs-meta">@bs</span>.send] external getElementById : <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">document</span>, <span class="hljs-built_in">string</span></span>) =&gt;</span> Dom.element = <span class="hljs-string">"getElementById"</span>;
[<span class="hljs-meta">@bs</span>.val] external doc : <span class="hljs-built_in">document</span> = <span class="hljs-string">"document"</span>;

<span class="hljs-keyword">let</span> el = getElementById(doc, <span class="hljs-string">"myId"</span>);
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myId"</span>);
</code></pre>
<p>En un <code>bs.send</code>, el objeto es siempre el primer argumento. Los verdaderos argumentos del método siguen (esto es como lo que los objetos OOP modernos son).</p>
<h3><a class="anchor" aria-hidden="true" name="encadenamiento"></a><a href="#encadenamiento" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Encadenamiento</h3>
<p>¿Alguna vez has usado el encandenamiento <code>foo().bar().baz()</code> (&quot;fluent api&quot;) en JS OOP? Podemos modelar eso en BuckleScript también, convirtiendo <code>bs.send</code> en <code>bs.send.pipe</code>, y usando el operador de stock <code>|&gt;</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> map : (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'b</span>) -&gt; <span class="hljs-symbol">'b</span> <span class="hljs-built_in">array</span> = <span class="hljs-string">""</span> [@@bs.send.pipe: <span class="hljs-symbol">'a</span> <span class="hljs-built_in">array</span>]
<span class="hljs-keyword">external</span> forEach: (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">unit</span>) -&gt; <span class="hljs-symbol">'a</span> <span class="hljs-built_in">array</span> = <span class="hljs-string">""</span> [@@bs.send.pipe: <span class="hljs-symbol">'a</span> <span class="hljs-built_in">array</span>]

<span class="hljs-keyword">let</span> _ =
  [|<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>|]
  |&gt; map (<span class="hljs-keyword">fun</span> x -&gt; x + <span class="hljs-number">1</span>)
  |&gt; forEach (<span class="hljs-keyword">fun</span> x -&gt; <span class="hljs-type">Js</span>.log x)
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.send.pipe : <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'a</span>)]
<span class="hljs-keyword">external</span> map : (<span class="hljs-symbol">'a</span> =&gt; <span class="hljs-symbol">'b</span>) =&gt; <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'b</span>) = <span class="hljs-string">""</span>;

[@bs.send.pipe : <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'a</span>)]
<span class="hljs-keyword">external</span> forEach : (<span class="hljs-symbol">'a</span> =&gt; <span class="hljs-built_in">unit</span>) =&gt; <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-string">""</span>;

[|<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>|]
|&gt; map((x) =&gt; x + <span class="hljs-number">1</span>)
|&gt; forEach((x) =&gt; <span class="hljs-type">Js</span>.log(x));
</code></pre>
<p>La carga a <code>bs.send.pipe</code> es lo que previamente habías puesto como el primer argumento de <code>bs.send</code>. Así que la manera non-bs-send-pipe de escribirlo hubiera sido:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> map : <span class="hljs-symbol">'a</span> <span class="hljs-built_in">array</span> -&gt; (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'b</span>) -&gt; <span class="hljs-symbol">'b</span> <span class="hljs-built_in">array</span> = <span class="hljs-string">""</span> [@@bs.send]
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.send] <span class="hljs-keyword">external</span> map : (<span class="hljs-built_in">array</span>(<span class="hljs-symbol">'a</span>), <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-symbol">'b</span>) =&gt; <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'b</span>) = <span class="hljs-string">""</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="argumento-de-funcion-variadica"></a><a href="#argumento-de-funcion-variadica" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Argumento de Función Variádica</h2>
<p>Puedes tener funciones JS que tomen una cantidad arbitraria de argumentos. BuckleScript soporta enlazar a esos, bajo la condición de que la parte de los argumentos arbitrarios es homogénea (es decir, del mismo tipo). Si es así, añade <code>bs.splice</code> a tu <code>external</code>.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> join : <span class="hljs-built_in">string</span> <span class="hljs-built_in">array</span> -&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"path"</span>] [@@bs.splice]
<span class="hljs-keyword">let</span> v = join [| <span class="hljs-string">"a"</span>; <span class="hljs-string">"b"</span>|]
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"path"</span>] [@bs.splice] <span class="hljs-keyword">external</span> join : <span class="hljs-built_in">array</span>(<span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>;
<span class="hljs-keyword">let</span> v = join([|<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>|]);
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> Path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">var</span> v = Path.join(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>);
</code></pre>
<p><em><code>bs.module</code> será explicada en la sección siguiente de Importación &amp; Exportación</em>.</p>
<h2><a class="anchor" aria-hidden="true" name="enlazar-a-una-funcion-polimorfica"></a><a href="#enlazar-a-una-funcion-polimorfica" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enlazar a una Función Polimórfica</h2>
<p>Aparte de los casos especiales anteriores, las funciones JS en general son a menudo sobrecargadas arbitrariamente en términos de tipos y número de argumentos ¿cómo enlazarías esos?</p>
<h3><a class="anchor" aria-hidden="true" name="truco-1-multiples-external-s"></a><a href="#truco-1-multiples-external-s" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Truco 1: Múltiples <code>external</code>s</h3>
<p>Si puedes exhaustivamente enumerar las distintas formas que una función JS sobrecargada puede tomar, simplemente enlázalas a cada una de manera diferente:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> drawCat: <span class="hljs-built_in">unit</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>]
<span class="hljs-keyword">external</span> drawDog: giveName:<span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>]
<span class="hljs-keyword">external</span> draw : <span class="hljs-built_in">string</span> -&gt; useRandomAnimal:<span class="hljs-type">Js</span>.boolean -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>]
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>] <span class="hljs-keyword">external</span> drawCat : <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>] <span class="hljs-keyword">external</span> drawDog : (~giveName: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"Drawing"</span>] <span class="hljs-keyword">external</span> draw : (<span class="hljs-built_in">string</span>, ~useRandomAnimal: <span class="hljs-type">Js</span>.boolean) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>Nota cómo los tres externals se enlazan a la misma función JS, <code>draw</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="truco-2-variante-polimorfica-bsunwrap"></a><a href="#truco-2-variante-polimorfica-bsunwrap" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Truco 2: Variante Polimórfica + <code>bs.unwrap</code></h3>
<p>Si tienes un impulso irresistible de decir &quot;si solo el argumento de esta función JS fuera variante en vez de de informalmente ser un <code>string</code> o <code>int</code>&quot;, entonces buenas noticias: ¡te proveemos esas propiedades <code>external</code> anotando un parámetro como una variante polimórfica! Asumiendo que tienes la siguiente función JS que quisieras enlazar:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value, padding</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(padding + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>) + value;
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"string"</span>) {
    <span class="hljs-keyword">return</span> padding + value;
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected string or number, got '<span class="hljs-subst">${padding}</span>'.`</span>);
}
</code></pre>
<p>Aquí, <code>padding</code> es en verdad una variante, conceptualmente. Modelémosla como una.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> padLeft :
  <span class="hljs-built_in">string</span>
  -&gt; ([ <span class="hljs-type">`Str</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span>
      | <span class="hljs-type">`Int</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span>
      ] [@bs.unwrap])
  -&gt; <span class="hljs-built_in">string</span>
  = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = padLeft <span class="hljs-string">"Hello World"</span> (<span class="hljs-type">`Int</span> <span class="hljs-number">4</span>)
<span class="hljs-keyword">let</span> _ = padLeft <span class="hljs-string">"Hello World"</span> (<span class="hljs-type">`Str</span> <span class="hljs-string">"Message from BS: "</span>)
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> padLeft : (
  <span class="hljs-built_in">string</span>,
  [@bs.unwrap] [
    | <span class="hljs-type">`Str</span>(<span class="hljs-built_in">string</span>)
    | <span class="hljs-type">`Int</span>(<span class="hljs-built_in">int</span>)
  ])
  =&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>;

padLeft(<span class="hljs-string">"Hello World"</span>, <span class="hljs-type">`Int</span>(<span class="hljs-number">4</span>));
padLeft(<span class="hljs-string">"Hello World"</span>, <span class="hljs-type">`Str</span>(<span class="hljs-string">"Message from BS: "</span>));
</code></pre>
<p>Obviamente, ¡el lado JS no podía tener un argumento que fuera una variante polimórfica! Pero aquí, solo estamos combinando en revisión y sintaxis de tipos de poli-variantes. El secreto es la anotación <code>[@bs.unwrap]</code> en el tipo. Esto desnuda los constructores de la variante y compila solo el valor de la carga. Salida:</p>
<pre><code class="hljs css js">padLeft(<span class="hljs-string">"Hello World"</span>, <span class="hljs-number">4</span>);
padLeft(<span class="hljs-string">"Hello World"</span>, <span class="hljs-string">"Message from BS: "</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="mejora-de-argumentos-de-restricciones"></a><a href="#mejora-de-argumentos-de-restricciones" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mejora de Argumentos de Restricciones</h2>
<p>Considera el nodo del segundo argumento de <code>fs.readFileSync</code>. Esto puede tomar una cadena, pero sólo un set definido: <code>&quot;ascii&quot;</code>, <code>&quot;utf8&quot;</code>, etc. Puedes seguir enlazándolo como cadenas, pero podemos usar poly variantes + <code>bs.string</code> para asegurar que nuestro uso es más correcto:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> readFileSync :
  name:<span class="hljs-built_in">string</span> -&gt;
  ([ `utf8
   | `useAscii [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"ascii"</span>]
   ] [@bs.<span class="hljs-built_in">string</span>]) -&gt;
  <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>
  [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"fs"</span>]

<span class="hljs-keyword">let</span> _ = readFileSync ~name:<span class="hljs-string">"xx.txt"</span> `useAscii
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-built_in">module</span> <span class="hljs-string">"fs"</span>]
external readFileSync : (
  ~<span class="hljs-name">name</span>: <span class="hljs-built_in">string</span>,
  [@bs.<span class="hljs-built_in">string</span>] [
    | `utf8
    | [@bs.as <span class="hljs-string">"ascii"</span>] `useAscii
  ])
  =&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>;

readFileSync(~name=<span class="hljs-string">"xx.txt"</span>, `useAscii);
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> Fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
Fs.readFileSync(<span class="hljs-string">"xx.txt"</span>, <span class="hljs-string">"ascii"</span>);
</code></pre>
<ul>
<li>Adjuntar <code>[@bs.string]</code> el tipo completo de poli variante hace que su constructor compile a una cadena del mismo tipo.</li>
<li>Adjuntar un <code>[@bs.as &quot;foo&quot;]</code> a un constructor te deja personalizar la cadena final.</li>
</ul>
<p>Y ahora, pasar algo como <code>&quot;myOwnUnicode&quot;</code> o otros nombres de constructores de variantes a <code>readFileSync</code> corregiría el error.</p>
<p>Aparte de cadenas, se puede compilar un argumento a un int, usando <code>bs.int</code> en vez de <code>bs.string</code> en una manera similar:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> test_int_type :
  ([ `on_closed
   | `on_open [@bs.<span class="hljs-keyword">as</span> <span class="hljs-number">20</span>]
   | `in_bin
   ]
   [@bs.<span class="hljs-built_in">int</span>]) -&gt; <span class="hljs-built_in">int</span> =
  <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = test_int_type `in_bin
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-selector-attr">[@bs.val]</span>
<span class="hljs-selector-tag">external</span> <span class="hljs-selector-tag">test_int_type</span> : (
  [<span class="hljs-variable">@bs</span>.int] [
    | <span class="hljs-built_in">`on_closed
    | [@bs.as 20] `</span>on_open
    | <span class="hljs-built_in">`in_bin
  ])
  =&gt; int = "";

test_int_type(`</span>in_bin);
</code></pre>
<p><code>on_closed</code> compilará a ``, <code>on_open</code> a <code>20</code> y <code>in_bin</code> a <strong><code>21</code></strong>.</p>
<h2><a class="anchor" aria-hidden="true" name="caso-especial-detectores-de-evento"></a><a href="#caso-especial-detectores-de-evento" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caso especial: Detectores de Evento</h2>
<p>Un ultimo truco con variantes polimórficas:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> readline
<span class="hljs-keyword">external</span> on :
    (
    [ `close <span class="hljs-keyword">of</span> <span class="hljs-built_in">unit</span> -&gt; <span class="hljs-built_in">unit</span>
    | `line <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span>
    ]
    [@bs.<span class="hljs-built_in">string</span>])
    -&gt; readline = <span class="hljs-string">""</span> [@@bs.send.pipe: readline]
<span class="hljs-keyword">let</span> register rl =
  rl
  |&gt; on (`close (<span class="hljs-keyword">fun</span> event -&gt; <span class="hljs-literal">()</span>))
  |&gt; on (`line (<span class="hljs-keyword">fun</span> line -&gt; print_endline line))
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">type readline;

[@bs.send.pipe : readline]
external <span class="hljs-literal">on</span> : (
  [@bs.string] [
    | `<span class="javascript">close(<span class="hljs-function"><span class="hljs-params">unit</span> =&gt;</span> unit)
    | </span>`line(string =&gt; unit)
  ])
  =&gt; readline = <span class="hljs-string">""</span>;

let register = <span class="hljs-function"><span class="hljs-params">(rl)</span> =&gt;</span>
  rl
  |&gt; <span class="hljs-literal">on</span>(`<span class="javascript">close(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> ()))
  |&gt; on(</span>`line(<span class="hljs-function"><span class="hljs-params">(line)</span> =&gt;</span> print_endline(line)));
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params">rl</span>) </span>{
  <span class="hljs-keyword">return</span> rl.on(<span class="hljs-string">"close"</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span><span class="hljs-number">0</span>;
            }))
            .on(<span class="hljs-string">"line"</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
              <span class="hljs-built_in">console</span>.log(line);
              <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span><span class="hljs-number">0</span>;
            }));
}
</code></pre>
<!-- TODO: GADT phantom type -->
<h2><a class="anchor" aria-hidden="true" name="argumentos-fijos"></a><a href="#argumentos-fijos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Argumentos Fijos</h2>
<p>Algunas veces es conveniente enlazar a una función usando <code>external</code>, mientras se pasan predeterminados valores de argumentos a la función JS:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> process_on_exit :
  (_ [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"exit"</span>]) -&gt;
  (<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span>) -&gt;
  <span class="hljs-built_in">unit</span> =
  <span class="hljs-string">"process.on"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = process_on_exit (<span class="hljs-keyword">fun</span> exit_code -&gt;
  <span class="hljs-type">Js</span>.log (<span class="hljs-string">"error code: "</span> ^ string_of_int exit_code)
)
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> process_on_exit : (
  [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"exit"</span>] _,
  <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">unit</span>
) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"process.on"</span>;

<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = process_on_exit((exit_code) =&gt;
  <span class="hljs-type">Js</span>.log(<span class="hljs-string">"error code: "</span> ++ string_of_int(exit_code))
);
</code></pre>
<p>Salida:</p>
<pre><code class="hljs css js">process.on(<span class="hljs-string">"exit"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exit_code</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error code: "</span> + exit_code);
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span><span class="hljs-number">0</span>;
});
</code></pre>
<p>El <code>[@bs.as &quot;exit&quot;]</code> y el argumento marcador <code>_</code> juntos indican que quieres que el primer argumento compile a la cadena <code>&quot;exit&quot;</code>. Además puedes usar cualquier JSON literal con <code>bs.as</code>: <code>[@bs.as {json|true|json}]</code>, <code>[@bs.as {json|{&quot;name&quot;: &quot;John&quot;}|json}]</code>, etc.</p>
<h2><a class="anchor" aria-hidden="true" name="curry-no-curry"></a><a href="#curry-no-curry" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Curry &amp; No-curry</h2>
<p>Curry es un delicioso plato hindú. Pero más importante, en el contexto de BuckleScript (y de programación funcional en general), &quot;currying&quot; significa que una función tomando múltiples argumentos se le pueden aplicar pocos argumentos a la vez, hasta que todos los argumentos son aplicados.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> add x y z = x + y + z
<span class="hljs-keyword">let</span> addFive = add <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> twelve = addFive <span class="hljs-number">3</span> <span class="hljs-number">4</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">add</span><span class="bash"> = (x, y, z) =&gt; x + y + z;
</span>let addFive = <span class="hljs-keyword">add</span><span class="bash">(5);
</span>let twelve = addFive(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre>
<p>¿Ves la función intermedia <code>addFive</code>? <code>add</code> toma tres argumentos pero recibió sólo 1. Es interpretado como hacer &quot;curry&quot; al argumento <code>5</code> y esperar por los otros 2 que sean aplicados más adelante. Firmas de tipo:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">val</span> add: <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span>
<span class="hljs-keyword">val</span> addFive: <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span>
<span class="hljs-keyword">val</span> twelve: <span class="hljs-built_in">int</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> add: (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> addFive: (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> twelve: <span class="hljs-built_in">int</span>;
</code></pre>
<p>(En un lenguaje dinámico como JS, hacer &quot;curry&quot; sería peligroso, ya que olvidar accidentalmente pasar un argumento no ocasiona un error al compilar).</p>
<h3><a class="anchor" aria-hidden="true" name="inconveniente"></a><a href="#inconveniente" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inconveniente</h3>
<p>Desafortunadamente, como JS no tiene &quot;curry&quot; debido a la razón ya mencionada, es difícil para funciones BS multi-argumentos mapear limpiamente a funciones JS el 100% de las veces:</p>
<ol>
<li><p>Cuando todos los argumentos de una función son suministrados (es decir, sin hacer curry), BS hace lo mejor para compilar, ejemplo, una llamada a 3 argumentos a una llamada JS plana con 3 argumentos.</p></li>
<li><p>Si es muy difícil de detectar cuando la aplicación de una función es completa*, BS usara un mecanismo de ejecución (el módulo <code>Curry</code>) para hacer curry tantos argumentos como podamos revisar cuando el resultado es completamente aplicado.</p></li>
<li><p>Algunos de los APIs JS como <code>throttle</code>, <code>debounce</code> y <code>promise</code> pueden meterse con el contexto, es decir usan el mecanismo de la función <code>bind</code>, el llevador <code>this</code>, etc. Esta implementación choca con la lógica de la aplicación anterior de curry.</p></li>
</ol>
<p>* Si el sitio de llamada es escrito como que tiene 3 argumentos, nosotros algunas veces no sabemos cuando es una función a la que se le está aplicando curry o si la original es en efecto de sólo 3 argumentos.</p>
<p>BS intenta hacer la #1 lo más que puede. Incluso cuando falla y usa el mecanismo de curry #2, no es peligroso usualmente.</p>
<p><strong>Sin embargo</strong>, si tu encuentras el #3, el tanteo no es lo suficientemente bueno: necesitas un camino garantizado de completamente aplicar una función, sin pasos intermediarios de curry. Nosotros proveemos esta garantía mediante el uso de la anotación &quot;para quitar el curry&quot; <code>[@bs]</code> en una declaración de función &amp; sitio de llamada.</p>
<h3><a class="anchor" aria-hidden="true" name="solucion-garantia-para-quitar-el-curry"></a><a href="#solucion-garantia-para-quitar-el-curry" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solución: Garantía para quitar el Curry</h3>
<p>Si anotas una firma de la declaración de la función en un <code>external</code> o un simple <code>let</code> con un <code>[@bs]</code>, conviertes esa función en una similar a la que se le puede quitar el curry:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> timerId
<span class="hljs-keyword">external</span> setTimeout : (<span class="hljs-built_in">unit</span> -&gt; <span class="hljs-built_in">unit</span> [@bs]) -&gt; <span class="hljs-built_in">int</span> -&gt; timerId = <span class="hljs-string">"setTimeout"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> id = setTimeout (<span class="hljs-keyword">fun</span> [@bs] <span class="hljs-literal">()</span> -&gt; <span class="hljs-type">Js</span>.log <span class="hljs-string">"hello"</span>) <span class="hljs-number">1000</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> timerId;
[@bs.val] external setTimeout : <span class="hljs-function"><span class="hljs-params">([@bs] (unit =&gt; unit), int)</span> =&gt;</span> timerId = <span class="hljs-string">"setTimeout"</span>;

let id = setTimeout([@bs] (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Js.log(<span class="hljs-string">"hello"</span>)), <span class="hljs-number">1000</span>);
</code></pre>
<p><strong>Nota</strong>: tanto el sitio de declaración y el sitio de llamada necesitan tener la anotación <code>[@bs]</code>.</p>
<p>Cuando tratas de hacer curry a esa función, obtendrás un error del tipo:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">fun</span> [@bs] x y z -&gt; x + y + z
<span class="hljs-keyword">let</span> addFiveOops = add <span class="hljs-number">5</span>
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">add</span><span class="bash"> = [@bs] ((x, y, z) =&gt; x + y + z);
</span>let addFiveOops = <span class="hljs-keyword">add</span><span class="bash">(5);
</span></code></pre>
<pre><code class="hljs">This is an uncurried bucklescript function. It must be applied with [@bs].
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="solucion-extra"></a><a href="#solucion-extra" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Solución Extra</h4>
<p>La solución anterior es segura, garantizada, y eficiente, pero a veces es un poco cargada visualmente. Te damos una solución alterna si:</p>
<ul>
<li>estas enlazando con <code>external</code></li>
<li>la función <code>external</code> toma un argumento que es otra función</li>
<li>quieres que el usuario no tenga la necesidad de anotar los sitios de llamada con <code>[@bs]</code></li>
</ul>
<!-- TODO: is this up-to-date info? -->
<p>Entonces intenta con <code>[@bs.uncurry</code>]:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> map : <span class="hljs-symbol">'a</span> <span class="hljs-built_in">array</span> -&gt; (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'b</span> [@bs.uncurry]) -&gt; <span class="hljs-symbol">'b</span> <span class="hljs-built_in">array</span> = <span class="hljs-string">""</span> [@@bs.send]
<span class="hljs-keyword">let</span> _ = map [|<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>|] (<span class="hljs-keyword">fun</span> x -&gt; x+ <span class="hljs-number">1</span>)
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">[@bs.send] <span class="hljs-keyword">external</span> map : (<span class="hljs-built_in">array</span>(<span class="hljs-symbol">'a</span>), [@bs.uncurry] (<span class="hljs-symbol">'a</span> =&gt; <span class="hljs-symbol">'b</span>)) =&gt; <span class="hljs-built_in">array</span>(<span class="hljs-symbol">'b</span>) = <span class="hljs-string">""</span>;
map([|<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>|], (x) =&gt; x + <span class="hljs-number">1</span>);
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="excepciones"></a><a href="#excepciones" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Excepciones</h4>
<p>Si intentas hacer esto:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> id : (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> [@bs]) = ((<span class="hljs-keyword">fun</span> v -&gt; v) [@bs])
</code></pre>
<p>Sintaxis de Reason:</p>
<pre><code class="hljs css reason">let id: [@bs] (<span class="hljs-string">'a =&gt; '</span>a) = [@bs] (<span class="hljs-function"><span class="hljs-params">(v)</span> =&gt;</span> v);
</code></pre>
<p>Obtendrás este mensaje de error críptico:</p>
<pre><code class="hljs">Error: este tipo de expresión, ('_a -&gt; '_a [@bs]),       contiene tipos de variables que no pueden ser generalizados
</code></pre>
<p>El problema aquí no es que la función sea polimórfica. Puedes usar las funciones polimórficas sin curry como retornos de llamada en línea, pero no puedes exportarlos (y los <code>let</code>s están expuestos por defecto a menos que los escondas en un archivo de interfaz). El problema aquí es una combinación de una llamada sin curry, poliformismo y exportar una función. Es una limitación desadortunada de como el tipo de sistema OCaml incorpora efectos secundarios, y de como BS maneja quitar el curry.</p>
<p>La soluciones más simples en la mayoría de los casos es simplemente no exportarlo, mediante la adición de un módulo de interfaz. Alternativamente, si tu realmente necesitas exportarlo, puedes hacerlo en su forma sin curry, y luego envolverlo en un lambda sin curry en el sitio de llamada. P.e.:</p>
<pre><code class="hljs css ocaml">lat _ = map (<span class="hljs-keyword">fun</span> v -&gt; id v [@bs])
</code></pre>
<h5><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h5>
<p>In general, <code>bs.uncurry</code> is recommended; the compiler will do lots of optimizations to resolve the currying to uncurrying at compile time. However, there are some cases the compiler can't optimize it. In these case, it will be converted to a runtime check.</p>
<p>This means <code>[@bs]</code> are completely static behavior (no runtime cost), while <code>[@bs.uncurry]</code> is more convenient for end users but, in some rare cases, might be slower than <code>[@bs]</code>.</p>
<h2><a class="anchor" aria-hidden="true" name="binding-to-this-based-callbacks"></a><a href="#binding-to-this-based-callbacks" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binding to <code>this</code>-based Callbacks</h2>
<p>Many JS libraries have callbacks which rely on this (the source), for example:</p>
<pre><code class="hljs css js">x.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.response + v)
}
</code></pre>
<p>Here, <code>this</code> would point to <code>x</code> (actually, it depends on how <code>onload</code> is called, but we digress). It's not correct to declare <code>x.onload</code> of type <code>unit → unit [@bs]</code>. Instead, we introduced a special attribute, <code>bs.this</code>, which allows us to type <code>x</code> as so:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> x
<span class="hljs-keyword">external</span> x: x = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> set_onload : x -&gt; (x -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> [@bs.this]) -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"onload"</span> [@@bs.set]
<span class="hljs-keyword">external</span> resp : x -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">"response"</span> [@@bs.get]

<span class="hljs-keyword">let</span> _ =
  set_onload x <span class="hljs-keyword">begin</span> <span class="hljs-keyword">fun</span> [@bs.this] o v -&gt;
    <span class="hljs-type">Js</span>.log(resp o + v )
  <span class="hljs-keyword">end</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type x;
[<span class="hljs-meta">@bs</span>.val] <span class="hljs-keyword">external</span> x : x = <span class="hljs-string">""</span>;
[<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">set</span>] <span class="hljs-keyword">external</span> set_onload : (x, [<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">this</span>] ((x, <span class="hljs-built_in">int</span>) =&gt; unit)) =&gt; unit = <span class="hljs-string">"onload"</span>;
[<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">get</span>] <span class="hljs-keyword">external</span> resp : x =&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">"response"</span>;

set_onload(x, [<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">this</span>] ((o, v) =&gt; Js.log(resp(o) + v)));
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">x.onload = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span>;
    <span class="hljs-built_in">console</span>.log(o.response + v | <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span><span class="hljs-number">0</span>;
  });
</code></pre>
<p><code>bs.this</code> is the same as <code>bs</code>, except that its first parameter is reserved for <code>this</code> and for arity of 0, there is no need for a redundant <code>unit</code> type.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="class.html">← Clase</a><a class="docs-next button" href="import-export.html">Importar y Exportar →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react'
              });
            </script></body></html>