<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Object (Deprecated) · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Object (Deprecated) · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/index.html"/><meta property="og:description" content="**Note**: this is the old API for binding to JS objects, kept for backward-compatibility. Please check the previous page for the current way of doing it."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible doc separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-CN/installation.html" target="_self">文档</a></li><li class=""><a href="/docs/zh-CN/playground.html" target="_self">Try</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/stdlib-overview.html" target="_self">API</a></li><li class=""><a href="/docs/zh-CN/community.html" target="_self">社区</a></li><li class=""><a href="/blog" target="_self">博客</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">帮助我们翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>互操作</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>简介</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-CN/what-why.html">什么 &amp; 为什么</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/installation.html">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/new-project.html">新建项目</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/concepts-overview.html">概念一览</a></li></ul></div><div class="navGroup navGroupActive"><h3>互操作</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-CN/interop-overview.html">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/interop-cheatsheet.html">备忘清单</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/embed-raw-javascript.html">嵌入原生Javascript</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/common-data-types.html">通用数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/intro-to-external.html">External简介</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/bind-to-global-values.html">全局变量</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/null-undefined-option.html">Null， Undefined， Option</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/object.html">对象</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/zh-CN/object-deprecated.html">Object (Deprecated)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/class.html">类</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/function.html">函数</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/import-export.html">导入 / 导出</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/regular-expression.html">正则表达式</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/exceptions.html">Exceptions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/json.html">JSON</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/fast-pipe.html">Fast Pipe</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/generate-converters-accessors.html">Generate Converters &amp; Helpers</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/better-data-structures-printing-debug-mode.html">Better Data Structures Printing (Debug Mode)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/nodejs-special-variables.html">NodeJS 特殊变量</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/interop-misc.html">Miscellaneous</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/browser-support-polyfills.html">浏览器支持和兼容</a></li></ul></div><div class="navGroup navGroupActive"><h3>构建系统</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-CN/build-overview.html">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/build-configuration.html">配置</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/automatic-interface-generation.html">Automatic Interface Generation</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/interop-with-js-build-systems.html">Interop with JS Build System</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/build-performance.html">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/build-advanced.html">高级</a></li></ul></div><div class="navGroup navGroupActive"><h3>标准库</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-CN/stdlib-overview.html">总览</a></li></ul></div><div class="navGroup navGroupActive"><h3>进阶</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-CN/conditional-compilation.html">Conditional Compilation</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/extended-compiler-options.html">Extended Compiler Options</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/use-existing-ocaml-libraries.html">使用现有的 OCaml 库</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/difference-from-native-ocaml.html">Difference from Native OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/compiler-architecture-principles.html">Compiler Architecture &amp; Principles</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/comparison-to-jsoo.html">Comparison to Js_of_ocaml</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1>Object (Deprecated)</h1></header><article><div><span><p><strong>Note</strong>: this is the old API for binding to JS objects, kept for backward-compatibility. Please check the previous page for the current way of doing it.</p>
<p>==============</p>
<p>JavaScript objects are used for so many purposes that if we had a single API for typing them, we'd likely end up with &quot;this is an object that can take potentially many unknown fields with many unknown value types&quot;, which isn't very useful.</p>
<p>BS splits the many overloaded usage of JS objects into distinct categories, for better UX and perf.</p>
<h2><a class="anchor" aria-hidden="true" id="object-as-record"></a><a href="#object-as-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as &quot;Record&quot;</h2>
<p>Use this API if your object:</p>
<ul>
<li>has a known number of fields</li>
<li>might or might not contain values of heterogeneous types</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="typing"></a><a href="#typing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typing</h3>
<p>Use the type <code>Js.t</code> that wraps an OCaml object type:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>
&gt; <span class="hljs-type">Js</span>.t

<span class="hljs-keyword">external</span> john : person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]
</code></pre>
<pre><code class="hljs css reason">type person = <span class="hljs-keyword">Js.t({
</span>  .
<span class="hljs-symbol">  name:</span> string,
<span class="hljs-symbol">  age:</span> int,
<span class="hljs-symbol">  job:</span> string
})<span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>From now on</strong>, we'll call the BuckleScript interop object &quot;<code>Js.t</code> object&quot;, to disambiguate it with normal object and JS object.</p>
<p>Because object types are used often, Reason gives it a nicer sugar. <code>Js.t({. name: string})</code> will format to <code>{. &quot;name&quot;: string}</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="accessors"></a><a href="#accessors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessors</h3>
<h4><a class="anchor" aria-hidden="true" id="read"></a><a href="#read" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Read</h4>
<p>To access a field, use <code>##</code>: <code>let johnName = john##name</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="write"></a><a href="#write" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write</h4>
<p>To modify a field, you need to first mark a field as mutable. By default, the <code>Js.t</code> object type is immutable.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; age : <span class="hljs-built_in">int</span> [@bs.set] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##age #= <span class="hljs-number">99</span>
</code></pre>
<pre><code class="hljs css reason">type person = {. [@<span class="hljs-keyword">bs.set] </span><span class="hljs-string">"age"</span>: int}<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>

<span class="hljs-keyword">john##age </span><span class="hljs-comment">#= 99;</span>
</code></pre>
<p><strong>Note</strong>: you can't use dynamic/computed keys in this paradigm.</p>
<h4><a class="anchor" aria-hidden="true" id="call"></a><a href="#call" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call</h4>
<p>To call a method of a field, mark the function signature as <code>[@bs.meth]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; say : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> [@bs.meth] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##say <span class="hljs-string">"hey"</span> <span class="hljs-string">"jude"</span>
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> person = {. [@bs.meth] <span class="hljs-string">"say"</span>: <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>)</span> =&gt;</span> unit};
[@bs.val] external john : person = <span class="hljs-string">"john"</span>;

john##say(<span class="hljs-string">"hey"</span>, <span class="hljs-string">"jude"</span>);
</code></pre>
<p><strong>Why <code>[bs.meth]</code></strong>? Why not just call it directly? A JS object might carry around a reference to <code>this</code>, and infamously, what <code>this</code> points to can change. OCaml/BuckleScript functions are curried by default; this means that if you intentionally curry <code>say</code>, by the time you fully apply it, the <code>this</code> context could be wrong:</p>
<pre><code class="hljs css ocaml"><span class="hljs-comment">(* wrong *)</span>
<span class="hljs-keyword">let</span> talkTo = john##say(<span class="hljs-string">"hey"</span>)

<span class="hljs-keyword">let</span> jude = talkTo <span class="hljs-string">"jude"</span>
<span class="hljs-keyword">let</span> paul = talkTo <span class="hljs-string">"paul"</span>
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* wrong */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">talkTo</span> = john<span class="hljs-comment">##say("hey");</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">jude</span> = talkTo(<span class="hljs-string">"jude"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-attr">paul</span> = talkTo(<span class="hljs-string">"paul"</span>);
</code></pre>
<p>To ensure that folks don't accidentally curry a JavaScript method, we track every method call using <code>##</code> to make sure it's fully applied <em>immediately</em>. Under the hood, we effectively turn a function-looking call into a special <code>bs.meth</code> call (it only <em>looks</em> like a function). Annotating the type definition of <code>say</code> with <code>bs.meth</code> completes this check.</p>
<h3><a class="anchor" aria-hidden="true" id="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>You can use <code>[%bs.obj putAnOCamlRecordHere]</code> DSL to create a JS object:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info = {author = <span class="hljs-string">"Bob"</span>}
}]

<span class="hljs-keyword">let</span> name = bucklescript##info##author
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info: {author: <span class="hljs-string">"Bob"</span>}
}];

<span class="hljs-keyword">let</span> name = bucklescript##info##author;
</code></pre>
<p>Because object values are used often, Reason gives it a nicer sugar. <code>[%bs.obj {foo: 1}]</code> will format to <code>{&quot;foo&quot;: 1}</code>.</p>
<p><strong>Note</strong>: there's no syntax sugar for creating an empty object in OCaml nor Reason (aka this doesn't work: <code>[@bs.obj {}]</code>. Please use <code>Js.Obj.empty()</code> for that purpose.</p>
<p>The created object will have an inferred type, no type declaration needed! The above example will infer as:</p>
<pre><code class="hljs css ocaml">&lt; info: &lt; author: <span class="hljs-built_in">string</span> &gt; <span class="hljs-type">Js</span>.t &gt; <span class="hljs-type">Js</span>.t
</code></pre>
<pre><code class="hljs css reason">{. <span class="hljs-string">"info"</span>: {. <span class="hljs-string">"author"</span>: string}}
</code></pre>
<p><strong>Note</strong>: since the value has its type inferred, <strong>don't</strong> accidentally do this:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;age: <span class="hljs-built_in">int</span>&gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">let</span> jane = [%bs.obj {age = <span class="hljs-string">"hi"</span>}]
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-attribute">type person</span> = {. <span class="hljs-string">"age"</span>: int};
<span class="hljs-attribute">let jane</span> = {<span class="hljs-string">"age"</span>: <span class="hljs-string">"hi"</span>};
</code></pre>
<p>See what went wrong here? We've declared a <code>person</code> type, but <code>jane</code> is inferred as its own type, so <code>person</code> is ignored and no error happens! To give <code>jane</code> an explicit type, simply annotate it: <code>let jane: person = ...</code>. This will then error correctly.</p>
<h4><a class="anchor" aria-hidden="true" id="special-creation-function"></a><a href="#special-creation-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Special Creation Function</h4>
<p>OCaml's optional labeled function maps rather nicely to a JS object creation. We provide an alternative way of creating objects, <code>bs.obj</code>, that is convenient if said object contains optional fields:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeConfig : high:<span class="hljs-built_in">int</span> -&gt; ?low:<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> -&gt; _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> c1 = makeConfig ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> c2 = makeConfig ~low:<span class="hljs-number">2</span> ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>

<span class="hljs-comment">(* access them as Js.t objects! *)</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-built_in">int</span> = c1##high
<span class="hljs-keyword">let</span> low: <span class="hljs-built_in">int</span> <span class="hljs-type">Js</span>.undefined = c1##low
</code></pre>
<pre><code class="hljs css reason">[@bs.obj] external makeConfig : (~high: int, ~low: <span class="hljs-attr">int=?,</span> unit) =&gt; <span class="hljs-attr">_</span> = <span class="hljs-string">""</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">c1</span> = makeConfig(~<span class="hljs-attr">high=3,</span> ());
<span class="hljs-keyword">let</span> <span class="hljs-attr">c2</span> = makeConfig(~<span class="hljs-attr">low=2,</span> ~<span class="hljs-attr">high=3,</span> ());

<span class="hljs-comment">/* access them as Js.t objects! */</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-attr">int</span> = c1<span class="hljs-comment">##high;</span>
<span class="hljs-keyword">let</span> low: Js.undefined(int) = c1<span class="hljs-comment">##low;</span>
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> c1 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>};
<span class="hljs-keyword">var</span> c2 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">low</span>: <span class="hljs-number">2</span>};
<span class="hljs-keyword">var</span> high = c1.high;
<span class="hljs-keyword">var</span> low = c1.low;
</code></pre>
<p><strong>Note</strong>:</p>
<ul>
<li><p>Marking the return value as <code>_</code> will infer a <code>Js.t</code> object of the expected shape!</p></li>
<li><p>The final <code>unit</code> is there to indicate that you've finished applying optional arguments. More info <a href="https://reasonml.github.io/docs/en/function.html#labeled-arguments">here</a>.</p></li>
</ul>
<p>You can also attach constant data unto an object using <code>[@bs.as]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeIOConfig :
  stdio:(_ [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"inherit"</span>]) -&gt;
  cwd:<span class="hljs-built_in">string</span> -&gt;
  detached:(_ [@bs.<span class="hljs-keyword">as</span> {json|<span class="hljs-literal">true</span>|json}]) -&gt;
  <span class="hljs-built_in">unit</span> -&gt;
  _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> config = makeIOConfig ~cwd:<span class="hljs-string">"."</span> <span class="hljs-literal">()</span>
</code></pre>
<pre><code class="hljs css reason">[@bs.obj]
external makeIOConfig : (
  ~stdio: [@bs.as <span class="hljs-string">"inherit"</span>] _,
  ~cwd: string,
  ~detached: [@bs.as {json|<span class="hljs-literal">true</span>|json}] _,
  unit
) =&gt; _ = <span class="hljs-string">""</span>;

let<span class="hljs-built_in"> config </span>= makeIOConfig(~<span class="hljs-attribute">cwd</span>=<span class="hljs-string">"."</span>, ());
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-attr">stdio</span>: <span class="hljs-string">"inherit"</span>,
  <span class="hljs-attr">cwd</span>: <span class="hljs-string">"."</span>,
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">true</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="name-mangling"></a><a href="#name-mangling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Name mangling</h3>
<h4><a class="anchor" aria-hidden="true" id="invalid-field-names"></a><a href="#invalid-field-names" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid field names</h4>
<p>Sometimes, you might encounter JavaScript object fields that start with capital letters or use reserved words. The latter is invalid and the former is reserved for module and variant names. To circumvent this, we support object label mangling/translation:</p>
<pre><code class="hljs css ocaml">stream##_open
stream##_MAX_LENGTH
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">stream.open;
stream.MAX_LENGTH;
</code></pre>
<p><strong>Double check your JS output</strong> to make sure your name mangling worked.</p>
<p><strong>If your key contains hyphens</strong>, you'll have to use it as a dynamic record, described later.</p>
<h4><a class="anchor" aria-hidden="true" id="ad-hoc-polymorphism"></a><a href="#ad-hoc-polymorphism" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ad-hoc Polymorphism</h4>
<p>Another form of name mangling is also supported, where a double underscore (<code>__</code>) can be used add a disambiguating identifier which will be removed in the generated JS.</p>
<pre><code class="hljs css ocaml">f##draw__int <span class="hljs-number">3</span> <span class="hljs-number">4</span>
f##draw__float <span class="hljs-number">3.2</span> <span class="hljs-number">4.5</span>
</code></pre>
<pre><code class="hljs css reason">f<span class="hljs-function"><span class="hljs-keyword">##</span><span class="hljs-title">draw__int</span><span class="hljs-params">(3, 4)</span></span>;
f<span class="hljs-function"><span class="hljs-keyword">##</span><span class="hljs-title">draw__float</span><span class="hljs-params">(3.2, 4.5)</span></span>;
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">f.draw(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
f.draw(<span class="hljs-number">3.2</span>, <span class="hljs-number">4.5</span>);
</code></pre>
<p>This can be useful in rare circumstances, but is generally not recommended since it produces non-idiomatic identifiers and is not very intuitive. Prefer instead to implement the object as a dynamic record (described below), or define an abstract untagged union type to encapsulate values of either type before passing them to or from JavaScript.</p>
<h3><a class="anchor" aria-hidden="true" id="js-object-ocaml-record-conversion"></a><a href="#js-object-ocaml-record-conversion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Js Object &lt;-&gt; OCaml Record conversion</h3>
<p>If you don't want to work with <code>Js.t</code> objects and want to use idiomatic OCaml/Reason records, we provide automatic generation of helpers that convert between a <code>Js.t</code> object and a corresponding record type. See the section on <a href="/docs/zh-CN/generate-converters-accessors.html">Generate Converters &amp; Helpers</a>.</p>
<!-- TODO: playground link -->
<h2><a class="anchor" aria-hidden="true" id="object-as-dynamic-record"></a><a href="#object-as-dynamic-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as Dynamic Record</h2>
<p>When The two above modes of talking to JS objects fail, you can always fall back to this one. And sometimes this the <strong>preferable</strong> way of talking to JS objects, because it:</p>
<ul>
<li>deals with objects with potentially arbitrary shapes</li>
<li>allows heterogeneous values</li>
<li><strong>allows hyphen and other symbols in object keys</strong></li>
</ul>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> t
<span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> -&gt; t = <span class="hljs-string">"Int32Array"</span> [@@bs.<span class="hljs-keyword">new</span>] <span class="hljs-comment">(* bs.new is documented in the class section *)</span>
<span class="hljs-keyword">external</span> get : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span> [@@bs.get_index]
<span class="hljs-keyword">external</span> set : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span> [@@bs.set_index]

<span class="hljs-keyword">let</span> i32arr = (create <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> _ = set i32arr <span class="hljs-number">0</span> <span class="hljs-number">42</span>
<span class="hljs-keyword">let</span> _ = <span class="hljs-type">Js</span>.log (get i32arr <span class="hljs-number">0</span>)
</code></pre>
<pre><code class="hljs css reason">type t;
[<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">new</span>] <span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> =&gt; t = <span class="hljs-string">"Int32Array"</span>; <span class="hljs-comment">/* bs.new is documented in the class section */</span>
[<span class="hljs-meta">@bs</span>.get_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">get</span> : (t, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span>;
[<span class="hljs-meta">@bs</span>.set_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">set</span> : (t, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; unit = <span class="hljs-string">""</span>;

let i32arr = create(<span class="hljs-number">3</span>);
<span class="hljs-keyword">set</span>(i32arr, <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);
Js.log(<span class="hljs-keyword">get</span>(i32arr, <span class="hljs-number">0</span>));
</code></pre>
<p>Albeit the names are called <code>get_index</code> and <code>set_index</code>, it's really dynamic access of objects fields and/or arrays.</p>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> i32arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(<span class="hljs-number">3</span>);
i32arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;
<span class="hljs-built_in">console</span>.log(i32arr[<span class="hljs-number">0</span>]);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="specific-getter-setter"></a><a href="#specific-getter-setter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specific Getter/Setter</h3>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> textarea
<span class="hljs-keyword">external</span> setName : textarea -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"name"</span> [@@bs.set]
<span class="hljs-keyword">external</span> getName : textarea -&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">"name"</span> [@@bs.get]

<span class="hljs-keyword">external</span> myTextArea: textarea = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">let</span> _ = setName myTextArea <span class="hljs-string">"asd"</span>
</code></pre>
<pre><code class="hljs css reason">type textarea<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.set] </span><span class="hljs-keyword">external </span>setName : (textarea, string) =&gt; unit = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.get] </span><span class="hljs-keyword">external </span>getName : textarea =&gt; string = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span>myTextArea : textarea = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
setName(myTextArea, <span class="hljs-string">"asd"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">myTextArea.name = <span class="hljs-string">"asd"</span>;
</code></pre>
<p>There's also a trick with object methods and method chaining in the next function section.</p>
<h2><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>All these tricks to bind to JS objects might be overwhelming; don't worry, you can just pick whatever you need as you go. But hopefully you can see that there's almost always a way to bind to your favorite JS library with no cost!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="object.html">← 对象</a><a class="docs-next button" href="class.html">类 →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#object-as-record">Object as &quot;Record&quot;</a><ul class="toc-headings"><li><a href="#typing">Typing</a></li><li><a href="#accessors">Accessors</a></li><li><a href="#creation">Creation</a></li><li><a href="#name-mangling">Name mangling</a></li><li><a href="#js-object-ocaml-record-conversion">Js Object OCaml Record conversion</a></li></ul></li><li><a href="#object-as-dynamic-record">Object as Dynamic Record</a><ul class="toc-headings"><li><a href="#specific-getter-setter">Specific Getter/Setter</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:zh-CN"]}
              });
            </script></body></html>