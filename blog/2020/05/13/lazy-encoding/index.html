<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Enhanced lazy encoding in BuckleScript · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Recently we made some significant improvements with our new encoding for lazy values and we find it so exciting that we want to highlight the changes. The new encoding generates very idiomatic JS output like hand-written ones."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Enhanced lazy encoding in BuckleScript · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/blog/2020/05/13/lazy-encoding"/><meta property="og:description" content="Recently we made some significant improvements with our new encoding for lazy values and we find it so exciting that we want to highlight the changes. The new encoding generates very idiomatic JS output like hand-written ones."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/blog/2020/05/13/lazy-encoding">Enhanced lazy encoding in BuckleScript</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/05/06/exception-encoding">A story of exception encoding in BuckleScript</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/04/13/release-7-3">What&#x27;s new in release 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/05/13/lazy-encoding">Enhanced lazy encoding in BuckleScript</a></h1><p class="post-meta">May 13, 2020</p><div class="authorBlock"></div></header><div><span><p>Recently we made some significant improvements with our new encoding for lazy values and we find it so exciting that we want to highlight the changes. The new encoding generates very idiomatic JS output like hand-written ones.</p>
<h1><a class="anchor" aria-hidden="true" id="whats-the-difference"></a><a href="#whats-the-difference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the difference?</h1>
<p>Take this code snippet for example:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> lazy1 = <span class="hljs-keyword">lazy</span> {
    <span class="hljs-string">"Hello, lazy"</span> -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log;
     <span class="hljs-number">1</span>
}; <span class="hljs-comment">// create a lazy value</span>

<span class="hljs-keyword">let</span> lazy2 = <span class="hljs-keyword">lazy</span> <span class="hljs-number">3</span> ; <span class="hljs-comment">// artifical lazy values for demo purpose</span>

<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log2 (lazy1, lazy2); <span class="hljs-comment">// logging the lazy values</span>

<span class="hljs-keyword">let</span> (<span class="hljs-keyword">lazy</span> la, <span class="hljs-keyword">lazy</span> lb) = (lazy1, lazy2); <span class="hljs-comment">// pattern match to force it evaluated</span>

<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log2 (la, lb); <span class="hljs-comment">// logging forced values</span>
</code></pre>
<p>Running this code in node, the output is as below:</p>
<pre><code class="hljs css language-bash">lazy_demo<span class="hljs-variable">$node</span> src/lazy_demo.bs.js 
[ [Function], tag: 246 ] 3 <span class="hljs-comment"># logging the output of two lazy blocks</span>
Hello, lazy
1 3
</code></pre>
<p>With the new encoding, the output is as below:</p>
<pre><code class="hljs css language-bash">bucklescript<span class="hljs-variable">$node</span> jscomp/<span class="hljs-built_in">test</span>/lazy_demo.js 
{ RE_LAZY: <span class="hljs-string">'todo'</span>, value: [Function: value] } <span class="hljs-comment"># logging block one</span>
{ RE_LAZY: <span class="hljs-string">'done'</span>, value: 3 } <span class="hljs-comment"># logging block two</span>
Hello, lazy
1 3
</code></pre>
<p>As you can see, with the new encoding, no magic tags like 246  appear, and the lazy status is clearly marked via <code>RE_LAZY: 'todo'</code> or <code>RE_LAZY: 'done'</code>.</p>
<p>More than that, the generated code quality is also improved, in the old mode, the generated JS code is like this:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> lazy1 = Caml_obj.caml_lazy_make((<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello, lazy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      }));

<span class="hljs-built_in">console</span>.log(lazy1, <span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> la = CamlinternalLazy.force(lazy1);

<span class="hljs-keyword">var</span> lb = CamlinternalLazy.force(<span class="hljs-number">3</span>);

<span class="hljs-built_in">console</span>.log(la, lb);

<span class="hljs-keyword">var</span> lazy2 = <span class="hljs-number">3</span>;
</code></pre>
<p>In the new mode, it is much simplified:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> lazy1 = {
  <span class="hljs-attr">RE_LAZY</span>: <span class="hljs-string">"todo"</span>,
  <span class="hljs-attr">value</span>: (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// internal function is using uncurried function for performance</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello, lazy"</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    })
};

<span class="hljs-keyword">var</span> lazy2 = {
  <span class="hljs-attr">RE_LAZY</span>: <span class="hljs-string">"done"</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>
};

<span class="hljs-built_in">console</span>.log(lazy1, lazy2);

<span class="hljs-keyword">var</span> la = CamlinternalLazy.force(lazy1);

<span class="hljs-keyword">var</span> lb = CamlinternalLazy.force(lazy2);

<span class="hljs-built_in">console</span>.log(la, lb);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="what-changes-do-we-make"></a><a href="#what-changes-do-we-make" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What changes do we make?</h2>
<p>In native, the encoding of lazy values is rather complicated:</p>
<ul>
<li>It is an array, which is not friendly for debugging in JS context.</li>
<li>It has some special tags which is not meaningful, for example, magic number 246,  in JS context.</li>
<li>It tries to unbox lazy values with the help of native GC, however, such complexity does not pay off in JS since JSVM does not expose its GC semantics.</li>
</ul>
<p>So in the master, our encoding scheme is much simplified to take advantage of JS as much as possible:</p>
<ul>
<li><p>The encoding is uniform, it is always an object of two key value pairs, one is <code>RE_LAZY</code> to mark its status,
the other is either a closure or an evaluated value.</p></li>
<li><p>The compiler optimization still kicks in at compile time: if it knows such lazy value is already evaluated or does not need to be evaluated, it will promote its status to be 'done'. However, unboxing is not happening unlike native. This makes sense since the most interesting unboxing scenarios happens in runtime instead of compile time where it is impossible in JSVM.</p></li>
</ul>
<p>With the new encoding, the lazy is a much nicer sugar and we encourage you to use it whenever it is convenient!</p>
<h1><a class="anchor" aria-hidden="true" id="caveats"></a><a href="#caveats" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caveats:</h1>
<p>Don't rely on the special name <code>RE_LAZY</code> for JS interop, we may change it to a symbol in the future.</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog">Recent Posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-changes-do-we-make">What changes do we make?</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>