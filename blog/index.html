<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A faster, simpler and more robust take on JavaScript."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/"/><meta property="og:description" content="A faster, simpler and more robust take on JavaScript."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/20/loading-stdlib-in-memory">Loading stdlib from memory</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/07/union-types-in-bucklescript">Union types in BuckleScript</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/04/release-7-1-0">bs-platform release 7.1.0</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></h1><p class="post-meta">March 26, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://github.com/facebook/reason">ReasonML</a> is a <a href="https://en.wikipedia.org/wiki/Currying">curried</a> language, while Js is an uncurried language. When compiling ReasonML into Js, there's lots of headache due to the semantics mismatch.</p>
<p>After several years of reasearch and development, we reach an ideal situation in next release: adding a lightweight uncurried calling convention to ReasonML.</p>
<h2><a class="anchor" aria-hidden="true" id="why-we-need-native-uncurried-calling-convention"></a><a href="#why-we-need-native-uncurried-calling-convention" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why we need native uncurried calling convention</h2>
<ul>
<li>Curried call is inherently slower than uncurried call.</li>
</ul>
<p>A native implementation of curried call like <a href="https://www.purescript.org/">purescript</a> does will generate very slow code:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> curriedFunction = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">z</span> =&gt;</span> x + y +z ;
<span class="hljs-keyword">let</span> curriedApply = curriedFunction(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// memory allocation triggered</span>
</code></pre>
<p>BuckleScript does tons of optimizations and very aggressive arity inference so that the curried function is actually compiled into multiple-arity function, and when the application is supplied with the exact arguments -- which is true in most cases, it is applied like normal functions.</p>
<p>However, such optimization does not apply to high order functions:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> highOrder =<span class="hljs-function"> (<span class="hljs-params">f</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)=&gt;</span> f (a, b) 
<span class="hljs-comment">// can not infer the arity of `f` since we know</span>
<span class="hljs-comment">// nothing about the arity of `f`, unless</span>
<span class="hljs-comment">// we do the whole program optimization</span>
</code></pre>
<p>In cases where arity infer does not help, the arity guessing has to be delayed into runtime.</p>
<ul>
<li>Bindings to JS world</li>
</ul>
<p>When we create bindings for high order functions in the JS world, we would like to have native uncurried functions which behave the same as JS world -- no semantics mismatch.</p>
<h2><a class="anchor" aria-hidden="true" id="generalized-uncurried-calling-convention-in-this-releases"></a><a href="#generalized-uncurried-calling-convention-in-this-releases" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generalized uncurried calling convention in this releases</h2>
<p>Prior to release 7.3, we had introduced uncurried calling convention, however, it has serious limitations -- uncurried functions can not be polymorphic, it does not support labels, the error
message leaks the underlying encoding -- now all those limitations are gone!</p>
<p>Previously</p>
<p><img src="/img/poly-error.png"></p>
<p><img src="/img/label-error.png"></p>
<p><img src="/img/recursive-error.png" ></p>
<p>The error messages above are cryptic and hard to understand. And the limitation of not supporting recursive functions make uncurried support pretty weak.</p>
<p>Now those limitations are all gone, you can have polymoprhic uncurried recursive functions and it support labels.</p>
<p><img src="/img/uncurry-label.png"></p>
<p><img src="/img/recursive.png"></p>
<p>The error message is  also enhanced significantly</p>
<ul>
<li>When uncurried functon is used in curried</li>
</ul>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> add =<span class="hljs-function"> (. <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>The old error message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(. int, int) =&gt; int
       This is <span class="hljs-keyword">not</span> a function; it cannot be applied.
</code></pre>
<p>The new error message</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function has uncurried type, it needs to be applied in ucurried style
</code></pre>
<ul>
<li>When curried function is used in uncurried context</li>
</ul>
<pre><code class="hljs css language-reasonml">
<span class="hljs-keyword">let</span> add =<span class="hljs-function"> ( <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>The old error message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(int, int) =&gt; int
       but an expression was expected of<span class="hljs-built_in"> type </span>(. <span class="hljs-string">'a, '</span>b) =&gt; <span class="hljs-string">'c
</span></code></pre>
<p>The new error message:</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function is a curried function where an uncurried function is expected
</code></pre>
<ul>
<li>When arity mismatch</li>
</ul>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> add =<span class="hljs-function"> (. <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
</code></pre>
<p>The old message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(. int, int) =&gt; int
       but an expression was expected of<span class="hljs-built_in"> type </span>(. <span class="hljs-string">'a, '</span>b, <span class="hljs-string">'c) =&gt; '</span>d
       These two variant types have <span class="hljs-literal">no</span> intersection
</code></pre>
<p>The new message:</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function has arity2 but was expected arity3
</code></pre>
<p>Note the generalized uncurry support also applies to objects, so that you can use <code>obj##meth (~label1=a,~label2=b)</code>.</p>
<p>The only thing where uncurried call  is not supported is optional arguments, if users are mostly targeting JS runtime, we suggest you can try uncurry by default and would like to hear your feedback!</p>
<p>You can already test it today by <code>npm install bs-platform@7.3.0-dev.1</code> (Windows support will be coming soon).</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></h1><p class="post-meta">March 12, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>Today we are proud to release <code>bs-platform 7.2</code>!</p>
<p>For those unfamiliar with bs-platform, it is the platform for compiling <a href="https://reasonml.github.io/">ReasonML</a> and <a href="https://ocaml.org/">OCaml</a> to fast and readable JavaScript.</p>
<p>You can try it with <code>npm i bs-platform</code>!</p>
<p>This is a major release with some highlighted features as below:</p>
<h2><a class="anchor" aria-hidden="true" id="in-memory-loading-stdlib"></a><a href="#in-memory-loading-stdlib" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In memory loading stdlib</h2>
<p>Since this release, the binary artifacts generated by the stdlib are loaded from memory instead of an external file systems, which means much faster compilation and installation.</p>
<p>Previously we recommended installing <code>bs-platform</code> globally to save on installation time.</p>
<p>However, with this release the installation is so fast that  we recommend installing it locally instead - per project - instead, as there's no additional cost, and it provides better isolation.</p>
<p>You can use it with a nice tool called <a href="https://www.npmjs.com/package/npx">npx</a>, for example, <code>npx bsb</code>.</p>
<p>The installation is also compatible with <code>--ignore-scripts</code> for major platforms (see <a href="https://youtu.be/okrB3aJtUaw?t=921">Richard Feldman's talk</a> on the security implications), and is more stable with <a href="https://github.com/yarnpkg/yarn">yarn</a></p>
<p>More technical details can be found in this <a href="https://bucklescript.github.io/blog/2020/02/20/loading-stdlib-in-memory">post</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="let-private"></a><a href="#let-private" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>let %private</h2>
<p>In OCaml's module system, everything is public by default, the only way to hide some values is by providing a separate signature to list public fields and their types:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">module</span> A : { <span class="hljs-keyword">let</span> b : <span class="hljs-built_in">int</span>} = {
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span> ;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">4</span> ; 
}
</code></pre>
<p><code>let</code> <code>%private</code> gives you an option to mark private fields directly</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">module</span> A  = {
    <span class="hljs-keyword">let</span>%<span class="hljs-keyword">private</span> a  = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">let</span> b  = <span class="hljs-number">4</span>;
}
</code></pre>
<p><code>let%private</code> also applies to file level modules, so in some cases, user does not need to provide a separate interface file just to hide some particular values.</p>
<p>Note interface files are still recommended as a general best practice since they give you better separate compilation units and also they're better for documentation. Still, <code>let%private</code> is useful in the following scenarios:</p>
<ul>
<li><p>Code generators. Some code generators want to hide some values but it is sometimes very hard or time consuming for code generators to synthesize the types for public fields.</p></li>
<li><p>Quick prototyping. During prototyping, we still want to hide some values, but the interface file is not stable yet, <code>let%private</code> provide you such convenience.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="int64-performance-optimization"></a><a href="#int64-performance-optimization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Int64 performance optimization</h2>
<p>We received feedback from some users that various Int64 operations became bottlenecks in their code performance, in particular <code>Int64.to_string</code>.</p>
<p>We responded to this, and after some hard work - but <em>without</em> changing the underlying representation - our <code>Int64.to_string</code> is even faster than <code>bigint</code> for common inputs.</p>
<p>A micro-benchmark for comparison:</p>
<pre><code class="hljs"><span class="hljs-string">running</span> <span class="hljs-string">on</span> <span class="hljs-number">7.1</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">367.</span><span class="hljs-string">788ms</span> <span class="hljs-comment"># super positive number </span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">140.</span><span class="hljs-string">451ms</span> <span class="hljs-comment"># median number</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">375.</span><span class="hljs-string">471ms</span> <span class="hljs-comment"># super negative number</span>

<span class="hljs-string">bigint</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">25.</span><span class="hljs-string">151ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">12.</span><span class="hljs-string">278ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">21.</span><span class="hljs-string">011ms</span>

<span class="hljs-string">latest</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">43.</span><span class="hljs-string">228ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">5.</span><span class="hljs-string">764ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">43.</span><span class="hljs-string">270ms</span>
</code></pre>
<p>We also apply such optimizations to other Int64 operations.</p>
<p>Note that Int64 is implemented in OCaml itself without any raw JavaScript. This is case compelling hints that our optimizing compiler not only provides expressivity and type-safe guarantees, but also empowers users to write maintainable, <em>efficient</em> code.</p>
<h2><a class="anchor" aria-hidden="true" id="file-level-compilation-flags"></a><a href="#file-level-compilation-flags" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>File level compilation flags</h2>
<p>In this release, we also provide a handy flag to allow users to override some configurations at the file level.</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-literal">[@<span class="hljs-identifier">bs</span>.<span class="hljs-identifier">config</span> {<span class="hljs-identifier">flags</span>: [|"-<span class="hljs-identifier">w</span>", "<span class="hljs-identifier">a</span>", "-<span class="hljs-identifier">bs</span>-<span class="hljs-identifier">no</span>-<span class="hljs-identifier">bin</span>-<span class="hljs-identifier">annot</span>"|]</span>}]; <span class="hljs-comment">// toplevel attributes</span>
</code></pre>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#72">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#72</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/20/loading-stdlib-in-memory">Loading stdlib from memory</a></h1><p class="post-meta">February 20, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="loading-stdlib-from-memory"></a><a href="#loading-stdlib-from-memory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading stdlib from memory</h2>
<!-- Do you mean "external files" instead of "external file system"? In Linux world, a file system is means something like EXT4 or btrfs -->
In the next release, we are going to load stdlib from memory instead of from external files, which will make the BuckleScript toolchain more accessible and performant.
<p>You can try it via <code>npm i bs-platform@7.2.0-dev.4</code></p>
<h2><a class="anchor" aria-hidden="true" id="how-does-it-work"></a><a href="#how-does-it-work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How does it work</h2>
<p>When the compiler compiles a module <code>test.ml</code>, the module <code>Test</code> will import some modules from stdlib. This is inevitable since even basic operators in BuckleScript, for example <code>(+)</code>, are defined in the Pervasives module, which is part of the stdlib.</p>
<p>Traditionally, the compiler will consult <code>Pervasives.cmi</code>, which is a binary artifact describing the interface of the Pervasives module and <code>Pervasives.cmj</code>, which is a binary artifact describing the implementation of the Pervasives module. <code>Pervasives.cm[ij]</code> and other modules in stdlib are shipped together with the compiler.</p>
<p>This traditional mode has some consequences:</p>
<ul>
<li>The compiler is not stand-alone and relocatable. Even if we have the compiler prebuilt for different platforms, we still have to compile stdlib post-installation. <code>postinstall</code> is supported by npm, but it has <a href="https://github.com/BuckleScript/bucklescript/issues/3213">various</a> <a href="https://github.com/BuckleScript/bucklescript/issues/2799">issues</a> <a href="https://github.com/BuckleScript/bucklescript/issues/3254">against</a> yarn.</li>
</ul>
<!-- I made my best guess as to what you mean by "they" in "However, they are still needed" (and tried to eliminate the repetition of the word "needed" -->
- It's hard to split the compiler from the generated stdlib JS artifacts. When a BuckleScript user deploys apps depending on BuckleScript, in theory, the app only needs to deploy those generated JS artifacts; the native binary is not needed in production. However, the artifacts are still loaded since they are bundled together. Allowing easy delivery of compiled code is one of the community’s most desired [feature requests](https://github.com/BuckleScript/bucklescript/issues/2772).
<p>In this release, we solve the problem by embedding the binary artifacts into the compiler directly and loading it on demand.</p>
<p>To make this possible, we try to make the binary data platform agnostic and as compact as possible to avoid size bloating. The entrance of loading cmi/cmj has to be adapted to this new way.</p>
<p>So whenever the compiler tries to load a module from stdlib, it will consult a lazy data structure in the compiler itself instead of consulting an external file system.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-the-benefit"></a><a href="#whats-the-benefit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the benefit?</h2>
<ul>
<li><p>More accessiblity.</p>
  <!-- In the phrase "we can make it installable", what does "it" refer to? -->
  Package installation now becomes downloading for prebuilt platforms. In the future, we can make it installable from a system package manager as well. The subtle interaction with [yarn reinstall](https://github.com/BuckleScript/bucklescript/issues/2799) is also solved once and for all.
</li>
</ul>
<ul>
<li><p>Easy separation between compiler and JS artifacts</p>
<p><!-- instead of "between compiler and stdlib version schemes", perhaps say "for aligning compiler and stdlib version schemes" -->
The compiler is just one relocatable file. This makes the separation between the compiler and generated JS artifacts easier. The remaining work is mostly to design a convention between compiler and stdlib version schemes.</p></li>
<li><p>Yes, better compile performance</p>
<p>A large set of files is not loaded from the file system but rather from memory now!</p></li>
<li><p>Fast installation and reinstallation.</p>
<p>Depending on your network speed, the installation is reduced from 15 seconds to 3 seconds. Reinstallation is almost a no-op now.</p></li>
</ul>
<!-- TODO: collect data points later -->
<ul>
<li><p>JS playground is easier to build</p>
<p><!-- I'm not sure what you mean by "compiling a single file to a string" -->
We translate the compiler into JS so that developers can play with it in the browser.  To make this happen, we used to fake the IO system; this not needed any more since no IO happens when compiling a single file to a string.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="some-internal-changes"></a><a href="#some-internal-changes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some internal changes</h2>
<p>To make this happen, the layout of binaries has been changed to the following structure. It is <strong>not recommended</strong> that users depend on the layout, but <a href="https://github.com/BuckleScript/bucklescript/pull/4170#issuecomment-586959464">it happens</a>. Here is the new layout:</p>
<pre><code class="hljs">
|<span class="hljs-string">-- bsb // node wrapper of bsb.exe
</span>|<span class="hljs-string">-- bsc // node wrapper of bsc.exe
</span>|
|<span class="hljs-string">-- win32
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe 
</span>|
|<span class="hljs-string">---darwin
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe
</span>|
|<span class="hljs-string">---linux
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe

</span></code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/07/union-types-in-bucklescript">Union types in BuckleScript</a></h1><p class="post-meta">February 7, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types">Union types</a></p>
<p>Union types describe a value that can be one of several types. In JS, it is common to use the vertical bar (|) to separate each type, so <code>number | string | boolean</code>  is the type of a value that can be a number, a string, or a boolean.</p>
<p>Following <a href="https://bucklescript.github.io/blog/2019/12/20/release-7-02">the last post</a> since the introduction of unboxed attributes in <code>7.1.0</code>, we can create such types as follows:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t = 
    | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span>  -&gt; t 
[@@unboxed]    
<span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> b (v : b) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> c (v : c) = <span class="hljs-type">Any</span> v
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t =
  | <span class="hljs-constructor">Any</span>('a): t;
<span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
<span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
<span class="hljs-keyword">let</span> c = (v: c) =&gt; <span class="hljs-constructor">Any</span>(v);
</code></pre>
<p>Note: due to the <code>unboxed</code> attribute, <code>Any a</code> shares the same runtime representation as <code>a</code>; however, we need to make sure that user can only construct values of type <code>a</code>, <code>b</code> , or <code>c</code> into type <code>t</code>. By making use of the module system, we can achieve this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">A_b_c</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> t 
  <span class="hljs-keyword">val</span> a : a -&gt; t 
  <span class="hljs-keyword">val</span> b : b -&gt; t 
  <span class="hljs-keyword">val</span> c : c -&gt; t   
<span class="hljs-keyword">end</span>= <span class="hljs-keyword">struct</span> 
<span class="hljs-keyword">type</span> t = 
    | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span>  -&gt; t 
[@@unboxed]    
<span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> b (v : b) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> c (v : c) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">A_b_c</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> a: a =&gt; t;
  <span class="hljs-keyword">let</span> b: b =&gt; t;
  <span class="hljs-keyword">let</span> c: c =&gt; t;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;  
  <span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> c = (v: c) =&gt; <span class="hljs-constructor">Any</span>(v);
};
</code></pre>
<!-- Union types are useful for modeling situations when values can overlap in the types they can take on.  -->
What happens when we need to know specifically whether we have a value of type `a`? This is a case by case issue; it depends on whether there are some intersections in the runtime encoding of `a`, `b` or `c`. For some primitive types, it is easy enough to use `Js.typeof` to tell the difference between, e.g, `number` and `string`. 
<p>Like <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">type guards in typescript</a>, we have to trust the user knowledge to differentiate between union types. However, such user level knowledge is isolated in a single module so that we can reason about its correctness locally.</p>
<p>Let's have a simple example, <code>number_or_string</code> first:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Number_or_string</span> : <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">Number</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> 
        | <span class="hljs-type">String</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span>
    <span class="hljs-keyword">val</span> number : <span class="hljs-built_in">float</span> -&gt; t 
    <span class="hljs-keyword">val</span> <span class="hljs-built_in">string</span> : <span class="hljs-built_in">string</span> -&gt; t 
    <span class="hljs-keyword">val</span> classify : t -&gt; case             
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
    <span class="hljs-keyword">type</span> t = 
        | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t 
    [@@unboxed]     
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">Number</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> 
        | <span class="hljs-type">String</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span>
    <span class="hljs-keyword">let</span> number (v : <span class="hljs-built_in">float</span>) = <span class="hljs-type">Any</span> v 
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">string</span> (v : <span class="hljs-built_in">string</span>) = <span class="hljs-type">Any</span> v     
    <span class="hljs-keyword">let</span> classify (<span class="hljs-type">Any</span> v : t) : case = 
        <span class="hljs-keyword">if</span> <span class="hljs-type">Js</span>.typeof v = <span class="hljs-string">"number"</span> <span class="hljs-keyword">then</span> <span class="hljs-type">Number</span> (<span class="hljs-type">Obj</span>.magic v  : <span class="hljs-built_in">float</span>)
        <span class="hljs-keyword">else</span> <span class="hljs-type">String</span> (<span class="hljs-type">Obj</span>.magic v : <span class="hljs-built_in">string</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Number_or_string</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">Number</span>(float)
    | <span class="hljs-constructor">String</span>(string);
  <span class="hljs-keyword">let</span> number: float =&gt; t;
  <span class="hljs-keyword">let</span> string: string =&gt; t;
  <span class="hljs-keyword">let</span> classify: t =&gt; case;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">Number</span>(float)
    | <span class="hljs-constructor">String</span>(string);
  <span class="hljs-keyword">let</span> number = (v: float) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> string = (v: string) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> classify = (<span class="hljs-constructor">Any</span>(v): t): case =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">Js</span>.typeof(v) <span class="hljs-operator">==</span> <span class="hljs-string">"number"</span>) {
      <span class="hljs-constructor">Number</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): float);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-constructor">String</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): string);
    };
};
</code></pre>
<p>Note that here we use <code>Obj.magic</code> to do an unsafe type cast which relies on <code>Js.typeof</code>. In practice, people may use <code>instanceof</code>; the following is an imaginary example:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">A_or_b</span> : <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">val</span> a : a -&gt; t 
    <span class="hljs-keyword">val</span> b : b -&gt; t 
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">A</span> <span class="hljs-keyword">of</span> a 
        | <span class="hljs-type">B</span> <span class="hljs-keyword">of</span> b 
    <span class="hljs-keyword">val</span> classify : t -&gt; case
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span>
    <span class="hljs-keyword">type</span> t = 
        | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
    [@@unboxed]   
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">A</span> <span class="hljs-keyword">of</span> a 
        | <span class="hljs-type">B</span> <span class="hljs-keyword">of</span> b 
    <span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v 
    <span class="hljs-keyword">let</span> b = (v : b) = <span class="hljs-type">Any</span> v
    <span class="hljs-keyword">let</span> classify ( <span class="hljs-type">Any</span> v : t)  = 
        <span class="hljs-keyword">if</span> [%raw{|<span class="hljs-keyword">function</span> (a) { return  a instanceof globalThis.<span class="hljs-type">A</span>}|}] v <span class="hljs-keyword">then</span> <span class="hljs-type">A</span> (<span class="hljs-type">Obj</span>.magic v : a)
        <span class="hljs-keyword">else</span> <span class="hljs-type">B</span> (<span class="hljs-type">Obj</span>.magic b)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">A_or_b</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> a: a =&gt; t;
  <span class="hljs-keyword">let</span> b: b =&gt; t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">A</span>(a)
    | <span class="hljs-constructor">B</span>(b);
  <span class="hljs-keyword">let</span> classify: t =&gt; case;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">A</span>(a)
    | <span class="hljs-constructor">B</span>(b);
  <span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> classify = (<span class="hljs-constructor">Any</span> (v): t) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-attribute">[%raw {|function (a) { return  a instanceof globalThis.A}|}]</span>(v)) {
      <span class="hljs-constructor">A</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): a);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-constructor">B</span>(<span class="hljs-module-identifier">Obj</span>.magic(b));
    };
};
</code></pre>
<p>Here we suppose <code>a</code> is of JS class type <code>A</code>, and we use <code>instanceof</code> to test it. Note we use some <code>unsafe</code> code locally, but as long as such code is carefully reviewed, it has a safe boundary at the module level.</p>
<p>To conclude: thanks to <code>unboxed</code> attributes and the module language, we introduce a systematic way to convert values from <code>union types</code> (untagged union types) to <code>algebraic data types</code> (tagged union types). This sort of conversion relies on user level knowledge and has to be reviewed carefully. For some cases where <code>classify</code> is not needed, it can be done in a completely type safe way.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/04/release-7-1-0">bs-platform release 7.1.0</a></h1><p class="post-meta">February 4, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform@7.1.0</code> is a major release. You can try it with <code>npm i -g bs-platform</code>!
(If you have permission issues, try <code>sudo npm i --unsafe-perm -g bs-platform</code>)</p>
<p>It was called 7.0.2 but bumped into 7.1.0 due to a soundness fix (a breaking change) as follows:</p>
<p>Previously, the empty array <code>[||]</code> was polymorphic. This happens to be true, since in native an array is not resizable, so users cannot do anything with it. But in JS, we introduced a binding for <code>push</code> which can change the size of an array dynamically. In this case, an empty array cannot be polymorphic any more.</p>
<p>Removing <code>push</code> is possible, but it makes arrays in JS context less useful. To fix this issue while keeping <code>push</code>, we make <code>[||]</code> weakly typed so that its type inference is deferred until the first time it is used. If it is never used across the module, it has to be annotated with a concrete type; otherwise, the type checker will complain.</p>
<p>Several highlighted features are listed as follows:</p>
<h2><a class="anchor" aria-hidden="true" id="raw-javascript-parsing-checking"></a><a href="#raw-javascript-parsing-checking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Raw JavaScript Parsing/Checking</h2>
<p>BuckleScript allows users to embed raw JavaScript code as an escape hatch; it used to treat such piece of code as a black box.</p>
<p>In this release we vendor a JavaScript parser (thanks to <a href="https://github.com/facebook/flow">flowtype</a>) for syntax checking and simple semantics analysis over <code>raw</code>. This is on-going work, but it is already useful now.</p>
<p>First, we now report syntax errors properly for <code>raw</code>.</p>
<p>Second, for simple semantics analysis, we can tell whether the code inside raw is a function or not and the arity of raw function:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = [%raw <span class="hljs-string">"function(x){return x}"</span>]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw "function(x){return x}"]</span>;
</code></pre>
<p>Now we know <code>f</code> is a function declaration with no side effect; it can be removed by the dead code analyzer if not used. We also know its arity so that when it's called we know whether it's fully applied or not.</p>
<p>Because this sort of information can be derived from <code>raw</code> directly, the special <code>raw</code> form we introduced as follows is no longer needed:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">fun</span>%raw x -&gt; {|x|}
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw x =&gt; {|x|}]</span>;
</code></pre>
<p>To reduce interop API surface, this feature will now be discouraged.</p>
<p>We're also exploring using such knowledge on JS literals and regexes checking.</p>
<h2><a class="anchor" aria-hidden="true" id="unboxed-types"></a><a href="#unboxed-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unboxed Types</h2>
<p>One major feature introduced in this release is <strong>unboxed types</strong> which is blogged <a href="https://bucklescript.github.io/blog/2019/12/20/release-7-02">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="uniform-warning-system"></a><a href="#uniform-warning-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uniform Warning System</h2>
<p>Previously warnings are reported in two ways:</p>
<ul>
<li>The OCaml compiler style: <code>-w +10</code></li>
<li>Ad-hoc warnings introduced by flags <code>-bs-warn-unimplemented-external</code></li>
</ul>
<p>In this release, we  make such integration so that BuckleScript warnings are handled in the same way as OCaml's own warnings, for example, the warning attribute below can also turn off  BuckleScript warnings now.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@warning "-101"]</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> file<span class="hljs-operator">-</span>level config
</code></pre>
<p>Based on this effort, we have changed all BuckleScript warnings into OCaml style warnings to reduce user-level complexity.</p>
<p>The newly introduced warnings are listed via <code>bsc -warn-help</code>:</p>
<pre><code class="hljs"><span class="hljs-symbol">101 </span>BuckleScript warning: Unused bs attributes
<span class="hljs-symbol">102 </span>BuckleScript warning: polymorphic comparison introduced (maybe unsafe)
<span class="hljs-symbol">103 </span>BuckleScript warning: about fragile FFI definitions
<span class="hljs-symbol">104 </span>BuckleScript warning: bs.deriving warning with customized message
<span class="hljs-symbol">105 </span>BuckleScript warning: the external <span class="hljs-keyword">name</span> is inferred from <span class="hljs-keyword">val</span> <span class="hljs-keyword">name</span> is unsafe from refactoring when changing value <span class="hljs-keyword">name</span>
<span class="hljs-symbol">106 </span>BuckleScript warning: Unimplemented primitive used:
<span class="hljs-symbol">107 </span>BuckleScript warning: Integer literal exceeds the range of representable integers of type <span class="hljs-keyword">int</span>
<span class="hljs-symbol">108 </span>BuckleScript warning: Uninterpreted delimiters (<span class="hljs-keyword">for</span> unicode)
</code></pre>
<p>We also recommend users to turn on <code>warnerror</code> and only disable warnings for some specific files.</p>
<p>We've also upgraded the Reason parser <code>refmt</code> to 3.6.0.</p>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/27/whats-new-in-7-cont">What&#x27;s new in release 7 (cont)</a></h1><p class="post-meta">December 27, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>[EDIT pre Dec. 27th: yes, we know the dateline is wrong :-) the actual publish date of this post is November 28th, but we're not changing the dateline because that would break the published URL of the post.]</p>
<p>The second dev release <a href="https://github.com/BuckleScript/bucklescript/pull/3995">7.0.0-dev.2</a> is released for testing!</p>
<p>As we mentioned in the <a href="https://bucklescript.github.io/blog/2019/11/18/whats-new-in-7">previous post</a>, we compile records into js objects in this release. This makes the generated code more idiomatic, however, this is not enough to write idiomatic bindings to manipulate arbitrary js objects, since the key of js objects can be arbitrary which is not expressible in ReasonML syntax, so we support user level customization now, which makes idiomatic bindings really easy.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> entry = {
  <span class="hljs-attribute">[@bs.as "EXACT_MAPPING_TO_JS_LABEL"]</span>
  x: int,
  <span class="hljs-attribute">[@bs.as "EXACT_2"]</span>
  y: int,
  z: obj,
}
<span class="hljs-keyword">and</span> obj = {
  <span class="hljs-attribute">[@bs.as "hello"]</span>
  hi: int,
};

<span class="hljs-keyword">let</span> f4 = ({x, y, z: {hi}}) =&gt; (x <span class="hljs-operator">+</span> y <span class="hljs-operator">+</span> hi) <span class="hljs-operator">*</span> <span class="hljs-number">2</span>;

</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> entry  = {
  x : <span class="hljs-built_in">int</span>  ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_MAPPING_TO_JS_LABEL"</span>]
  y : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_2"</span>]
  z : obj
} 
<span class="hljs-keyword">and</span> obj = {
  hi : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"hello"</span>]  
}    

<span class="hljs-keyword">let</span> f4  { x; y; z = {hi }} = 
  (x + y + hi) * <span class="hljs-number">2</span>
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params">param</span>) </span>{
  <span class="hljs-keyword">return</span> (((param.EXACT_MAPPING_TO_JS_LABEL + param.EXACT_2 | <span class="hljs-number">0</span>) + param.z.hello | <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-number">1</span>);
}
</code></pre>
<p>As you can see, you can manipulate js objects using Reason pattern match syntax, the generated
code is highly efficient, more importantly, bindings to JS will be significantly simplifie.</p>
<p>Happy Hacking.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/20/release-7-02">BuckleScript holiday release!</a></h1><p class="post-meta">December 20, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://github.com/BuckleScript/bucklescript/pull/4062">bs-platform@7.0.2-dev.1</a> is released for testing!</p>
<p>Try it via</p>
<pre><code class="hljs"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">-g</span> <span class="hljs-selector-tag">bs-platform</span>@<span class="hljs-keyword">7</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">2</span>-<span class="hljs-keyword">dev</span>.<span class="hljs-keyword">1</span>
</code></pre>
<p>This release contains several bug fixes for <a href="https://github.com/facebook/reason">refmt</a>(updated from 3.5.1 to 3.5.4). We also spent quite some time improving the compiler performance. For example, we optimized our specialized hash based data structures, which means that we can expect a 5% better build time performance. We would like to collect more benchmark data, so we are happy for any feedback / benchmarks from our community!</p>
<p>A highlighting feature is that we added Generalized Unboxed Support (so called [@unboxed] annotations). Here's a short definition from the official OCaml Manual:</p>
<blockquote>
<p>unboxed can be used on a type definition if the type is a single-field record or a concrete type with a single constructor that has a single argument. It tells the compiler to optimize the representation of the type by removing the block that represents the record or the constructor (i.e. a value of this type is physically equal to its argument). In the case of GADTs, an additional restriction applies: the argument must not be an existential variable, represented by an existential type variable, or an abstract type constructor applied to an existential type variable.</p>
</blockquote>
<p><strong>Note</strong>: The beforementioned restriction about GADTs only applies to OCaml's native compiler, not to BuckleScript's JavaScript compilation. So we will get the maximum value with less confusing error messages!</p>
<p>The exciting thing about this feature is that we will now have more ways of expressing our programs in our typical type safe records and variants without sacrificing on runtime performance (&quot;zero cost interop&quot;).</p>
<p>The best way to understand this feature is by looking at the following examples:</p>
<p><strong>Unboxed variants:</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = <span class="hljs-constructor">A</span>(int);
<span class="hljs-keyword">let</span> x = <span class="hljs-constructor">A</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
</code></pre>
<p>As you can see, we are &quot;unboxing&quot; the <code>int</code> value from the internal variant representation, so the variant will get completely invisible to the runtime. Great for e.g. mapping to stringly typed JavaScript enums!</p>
<p><strong>Unboxed Records (1 field only)</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t2 = {f: string};
<span class="hljs-keyword">let</span> x = {f: <span class="hljs-string">"foo"</span>};
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">"foo"</span>;
</code></pre>
<p>The same principle as with variants. Now a lot of people will probably ask: &quot;Why would I ever want a 1 field record?&quot;. There are multiple reasons, one of them would be a <code>ref</code> type, which is just a syntax sugar for a <code>{ contents: 'a}</code> record.</p>
<p>Another use case is for expressing high rank polymorphism without cost:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> r = {f: 'a. 'a =&gt; 'a};
<span class="hljs-keyword">let</span> map_pair = (r, (p1, p2)) =&gt; (r.f(p1), r.f(p2));
</code></pre>
<p><strong>Note:</strong> <code>'a. 'a =&gt; 'a</code> describes a polymorphic function interface, where <code>'a</code> can be called with many different types (e.g. <code>f(1)</code> and <code>f(&quot;hi&quot;)</code>). The compiler will not try to lock <code>'a</code> for the first type it sees (e.g. the <code>int</code>) on the first call site. The parameter <code>'a</code> is therefore polymorphic!</p>
<p>By <code>unboxing</code> those records with one polymorphic function,  we will get rid of <a href="https://github.com/BuckleScript/bucklescript/issues/4058">value restriction for our existing encoding of uncurried function</a>, this will be a major feature!</p>
<p><strong>Unboxed GADTs:</strong></p>
<p>Since GADTs are lesser known in Reason syntax, we also added some OCaml snippet to get a better idea of how the example data structure is defined.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-constructor">Any</span> ('a) : t; 

<span class="hljs-keyword">let</span> array = <span class="hljs-literal">[|</span><span class="hljs-constructor">Any</span>(<span class="hljs-number">3</span>), <span class="hljs-constructor">Any</span>(<span class="hljs-string">"a"</span>)<span class="hljs-literal">|]</span>;
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
[@@unboxed]

<span class="hljs-keyword">let</span> <span class="hljs-built_in">array</span> = [|<span class="hljs-type">Any</span> <span class="hljs-number">3</span>; <span class="hljs-type">Any</span> <span class="hljs-string">"a"</span>|]
</code></pre>
<p>The examples above will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> array = [ <span class="hljs-number">3</span>, <span class="hljs-string">"a"</span>];
</code></pre>
<p>As you can already tell, this feature will give us way better possibilities to do interop with polymorphic array representations in JavaScript (without losing any type safetiness!).</p>
<p>As a more concrete use-case, this will give users the possibility to define types such as <code>int_or_string</code>.</p>
<p><strong>Note:</strong> Even if this GADT <code>t</code> contains an ADT <code>Any</code>, it doesn't mean that it's the same as <code>any</code> in TypeScript. An <code>Any</code> value is constrained to a certain contract (<code>'a -&gt; t</code>), the array <code>[|Any(3), Any(&quot;a&quot;)|]</code> is inferred as a <code>array(t)</code>. When users try to use <code>Any</code> values, they need to unpack them, process the value inside, and repack them again. Pretty neat, right?</p>
<h3><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>
<p>This release will introduce the <code>[@unbox]</code> annotation to give us better ways to do zero cost interop with variants, records, higher kinded polymorphic functions, and GADTs. Under the hood improvements will give us better performance as well!</p>
<p>We are really excited about these changes, and we hope so are you. Please check out our newest <code>bs-platform@7.0.2-dev.1</code> release and let us know if you find any issues!</p>
<p>A detailed list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
<p>Happy hacking!</p>
<h3><a class="anchor" aria-hidden="true" id="appendix"></a><a href="#appendix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appendix</h3>
<p><strong>A sophiscated explanation on why <code>unboxed</code> lifts some OCaml's type system limitations</strong></p>
<blockquote>
<p>structural types (objects, classes, polymorphic variants, functions, etc) in
OCaml are regular types, ocaml always do the expansion when dealing with such
types, there is some limitations for such structural types, for example, non
regular definitions are not allowed. Non structural types (variants, records)
does not have such limitations, with <code>unboxed</code>, we can use non structural
types as an indirection without changing its runtime representations.</p>
</blockquote>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/11/18/whats-new-in-7">What&#x27;s new in release 7</a></h1><p class="post-meta">November 18, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>The new major version of BuckleScript is coming -<a href="https://github.com/BuckleScript/bucklescript/pull/3968">7.0.0-dev.1</a> released for testing!</p>
<p>We are maintaining <code>5.*</code> and <code>6.*</code> for OCaml <code>4.02</code> and <code>4.06</code> for a while, since this release we are moving forward and focusing on release 7.* (for OCaml 4.06).</p>
<p>This is a major release comes with lots of nice features listed <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md">here</a>.</p>
<p>We talk about some highlights here</p>
<ul>
<li><p>refmt upgraded to latest, it comes with better error message</p></li>
<li><p>OCaml Records compiled into JS objects</p></li>
</ul>
<p>This is one of the most desired features, it is finally landed.</p>
<p>See the generated code below for excitement!</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> t = {
  x: <span class="hljs-built_in">int</span>,
  y: <span class="hljs-built_in">int</span>,
  z: <span class="hljs-built_in">int</span>,
};

<span class="hljs-keyword">let</span> obj = {x: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, z: <span class="hljs-number">2</span>};

<span class="hljs-keyword">let</span> obj2 = {...obj, y: <span class="hljs-number">4</span>};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t = {
  x : <span class="hljs-built_in">int</span>;
  y : <span class="hljs-built_in">int</span>;
  z : <span class="hljs-built_in">int</span> 
}

<span class="hljs-keyword">let</span> obj = { x = <span class="hljs-number">3</span> ; y = <span class="hljs-number">2</span>; z = <span class="hljs-number">2</span>}

<span class="hljs-keyword">let</span> obj2 = { obj <span class="hljs-keyword">with</span> y = <span class="hljs-number">4</span>}
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};
</code></pre>
<p>This new change makes record much more useful and its interaction with <code>private</code> type; unboxed option type will make interop with JS much nicer!</p>
<p>As always, we continue improving our optimizer in various <a href="https://github.com/BuckleScript/bucklescript/pull/3966/files?file-filters%5B%5D=.js">commits</a>, we belive that not only a better language but also an implementation of high quality is key to push typed functional programming into industry.</p>
<p>Happy hacking!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/10/16/another-encoding">Another way of encoding type identity for BuckleScript libraries without using big functor</a></h1><p class="post-meta">October 16, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>Note this article is for library authors, it has something in depth which is not necessary for people who use BuckleScript at daily work.</p>
<p>When we build some generic data structure, abstract over function is not enough. For example,  a type safe generic balanced AVL tree not only relies on the types of a comparison function, but also the identity of such function. Two balanced AVL trees which are initialized over same type of comparison function still can not be mixed.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Eq1</span> = {
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Eq1</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">let</span> eq x y = x = y
<span class="hljs-keyword">end</span> 
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Eq2</span> = {
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Eq2</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">let</span> eq x y = x * x = y * y 
<span class="hljs-keyword">end</span>
</code></pre>
<p>Take the two modules above for example, they have the same type, but we need a way to mark their identity so that data structures instantiated using them can not be mixed.</p>
<p>A traditional way is using functor:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> (<span class="hljs-type">Cmp</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> t 
  <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span>
<span class="hljs-keyword">end</span>) = 
(<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">open</span> <span class="hljs-type">Cmp</span>
  <span class="hljs-keyword">type</span> key = t
  <span class="hljs-keyword">type</span> coll = key <span class="hljs-built_in">list</span> 
  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[]</span>
  <span class="hljs-keyword">let</span> add  (y : coll) (e : key) = 
    <span class="hljs-keyword">if</span> <span class="hljs-type">List</span>.exists (<span class="hljs-keyword">fun</span> x -&gt; eq x e) y <span class="hljs-keyword">then</span>
      y
    <span class="hljs-keyword">else</span>      
      e::y
<span class="hljs-keyword">end</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> key = <span class="hljs-type">Cmp</span>.t 
  <span class="hljs-keyword">type</span> coll
  <span class="hljs-keyword">val</span> empty : coll
  <span class="hljs-keyword">val</span> add : coll -&gt; key -&gt; coll
<span class="hljs-keyword">end</span> )

<span class="hljs-keyword">module</span> <span class="hljs-type">Ins1</span> = <span class="hljs-type">Make</span>(<span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span> 
  <span class="hljs-keyword">let</span> eq x y = x = y 
<span class="hljs-keyword">end</span>)
<span class="hljs-keyword">module</span> <span class="hljs-type">Ins2</span> = <span class="hljs-type">Make</span>(<span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span> 
  <span class="hljs-keyword">let</span> eq x y = x * x = y * y
<span class="hljs-keyword">end</span>)
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span> = (
  <span class="hljs-module-identifier">Cmp</span>: {
    <span class="hljs-keyword">type</span> t;
    <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
  }) : {
 <span class="hljs-keyword">type</span> key = <span class="hljs-module-identifier">Cmp</span>.t;
 <span class="hljs-keyword">type</span> coll;
 <span class="hljs-keyword">let</span> empty: coll;
 <span class="hljs-keyword">let</span> add: (coll, key) =&gt; coll;
} =&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Cmp</span>;
  <span class="hljs-keyword">type</span> key = t;
  <span class="hljs-keyword">type</span> coll = list(key);
  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[</span><span class="hljs-literal">]</span>;
  <span class="hljs-keyword">let</span> add = (y: coll, e: key) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">List</span>.exists(x =&gt; eq(x, e), y)) {
      y;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-literal">[</span>e, <span class="hljs-operator">...</span>y<span class="hljs-literal">]</span>;
    };
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Ins1</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
});
<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Ins2</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">*</span> x <span class="hljs-operator">==</span> y <span class="hljs-operator">*</span> y;
});
</code></pre>
<p>By marking <code>coll</code> as abstract type, when such functor is initialized,<code>Ins1.coll</code> and <code>Ins2.coll</code> are no longer the same.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> v = [<span class="hljs-type">Ins1</span>.empty; <span class="hljs-type">Ins2</span>.empty]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> v = <span class="hljs-literal">[</span><span class="hljs-module-identifier">Ins1</span>.empty, <span class="hljs-module-identifier">Ins2</span>.empty<span class="hljs-literal">]</span>;
</code></pre>
<p>When mixing them together, we get a type error</p>
<pre><code class="hljs">File <span class="hljs-built_in">..</span>., line 31, characters 21-31:
Error: This expression has<span class="hljs-built_in"> type </span>Ins2.coll
       but an expression was expected of<span class="hljs-built_in"> type </span>Ins1.coll
</code></pre>
<p>There are some issues with such encoding:</p>
<ul>
<li><p>From runtime point of view, <code>Ins1</code> is initialized during runtime, its implementation is a <em>big closure</em>, which means even if you only use on function in <code>Ins1</code> module, all functions will be linked in.</p></li>
<li><p>From user point of view, people has to call <code>Ins1.add</code> and <code>Ins2.add</code> instead of calling <code>Ins.add</code>, this makes code less polymorphic.</p></li>
</ul>
<p>Now we introduce another encoding, note it is quite sophiscated that is recommended only for library authors</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Cmp</span>: {
  <span class="hljs-keyword">type</span> cmp('a, 'id);
  <span class="hljs-keyword">let</span> eq: (cmp('a, 'id), 'a, 'a) =&gt; bool;
  <span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span>: (
    <span class="hljs-constructor">M</span>: {
       <span class="hljs-keyword">type</span> t;
       <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
     }
  ) =&gt; {
    <span class="hljs-keyword">type</span> identity;
    <span class="hljs-keyword">let</span> eq: cmp(<span class="hljs-module-identifier">M</span>.t, identity);
  };
} = {
  <span class="hljs-keyword">type</span> cmp('a, 'id) = ('a, 'a) =&gt; bool;
  <span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span> = (
    <span class="hljs-module-identifier">M</span>: {
     <span class="hljs-keyword">type</span> t;
     <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
    }
  ) =&gt; {
    <span class="hljs-keyword">type</span> identity;
    <span class="hljs-keyword">include</span> <span class="hljs-module-identifier">M</span>;
  };
  <span class="hljs-keyword">let</span> eq = (cmp, x, y) =&gt; cmp(x, y); <span class="hljs-comment">/* This could be inlined by using externals */</span>
};

<span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Cmp</span>;

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Coll</span>: {
  <span class="hljs-keyword">type</span> coll('k, 'id);
  <span class="hljs-keyword">let</span> empty: cmp('k, 'id) =&gt; coll('k, 'id);
  <span class="hljs-keyword">let</span> add: (coll('k, 'id), 'k) =&gt; coll('k, 'id);
} = {
  <span class="hljs-keyword">type</span> coll('k, 'id) = {
    eq: cmp('k, 'id),
    data: list('k),
  };

  <span class="hljs-keyword">let</span> empty = (<span class="hljs-keyword">type</span> t, <span class="hljs-keyword">type</span> identity, eq: cmp(t, identity)) =&gt; {
    data: <span class="hljs-literal">[</span><span class="hljs-literal">]</span>,
    eq,
  };
  <span class="hljs-keyword">let</span> add = (x: coll('k, 'id), y: 'k) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">List</span>.exists(a =&gt; <span class="hljs-module-identifier">Cmp</span>.eq(x.eq, a, y), x.data)) {
      x;
    } <span class="hljs-keyword">else</span> {
      {
        data: <span class="hljs-literal">[</span>y, <span class="hljs-operator">...</span>x.data<span class="hljs-literal">]</span>,
        eq: x.eq,
      };
    };
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Cmp</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'id</span>) cmp 
  <span class="hljs-keyword">val</span> eq : (<span class="hljs-symbol">'a</span>,<span class="hljs-symbol">'id</span>) cmp -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">bool</span>
  <span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> : <span class="hljs-keyword">functor</span> (<span class="hljs-type">M</span> : 
    <span class="hljs-keyword">sig</span> <span class="hljs-keyword">type</span> t 
      <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span> 
    <span class="hljs-keyword">end</span>
  ) -&gt; <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> identity
    <span class="hljs-keyword">val</span> eq :  (<span class="hljs-type">M</span>.t, identity) cmp
  <span class="hljs-keyword">end</span> 

<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'id</span>) cmp = <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">bool</span>
  <span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> (<span class="hljs-type">M</span>: <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span>  
  <span class="hljs-keyword">end</span>) = <span class="hljs-keyword">struct</span> 
    <span class="hljs-keyword">type</span> identity
    <span class="hljs-keyword">include</span> <span class="hljs-type">M</span>
  <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">let</span> eq cmp x y = cmp x y <span class="hljs-comment">(* This could be inlined by using externals *)</span>
<span class="hljs-keyword">end</span> 

<span class="hljs-keyword">open</span> <span class="hljs-type">Cmp</span> 

<span class="hljs-keyword">module</span> <span class="hljs-type">Coll</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll
  <span class="hljs-keyword">val</span> empty : (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) cmp -&gt; (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) coll
  <span class="hljs-keyword">val</span> add : (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll -&gt; <span class="hljs-symbol">'k</span> -&gt; (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) coll 
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll = {
    eq :   (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) cmp;
    data :  <span class="hljs-symbol">'k</span> <span class="hljs-built_in">list</span> 
  }

  <span class="hljs-keyword">let</span> empty (<span class="hljs-keyword">type</span> t) (<span class="hljs-keyword">type</span> identity) (eq : (t,identity) cmp) = {
    data = <span class="hljs-literal">[]</span>;
    eq = eq 
  }

  <span class="hljs-keyword">let</span> add (x : (<span class="hljs-symbol">'k</span>,<span class="hljs-string">' id) coll) (y : '</span>k) =  
    <span class="hljs-keyword">if</span> <span class="hljs-type">List</span>.exists (<span class="hljs-keyword">fun</span> a -&gt; <span class="hljs-type">Cmp</span>.eq x.eq a y) x.data <span class="hljs-keyword">then</span> x
    <span class="hljs-keyword">else</span> {
      data = y:: x.data;
      eq = x.eq 
    }
<span class="hljs-keyword">end</span> 

</code></pre>
<p>The key is the construction of Cmp modules, we create an abstract type <code>cmp</code> which is signed by a phantom type as its identity, it is unique whenever user create it by calling <code>Make</code> functor. Here we are still using functor, but it is small functor.</p>
<p>The usage is as below:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">S0</span> = <span class="hljs-type">Make</span> (<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span>
    <span class="hljs-keyword">let</span> eq x y = x = y
  <span class="hljs-keyword">end</span>)

<span class="hljs-keyword">module</span> <span class="hljs-type">S1</span> = <span class="hljs-type">Make</span> (<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> t  = <span class="hljs-built_in">int</span>
    <span class="hljs-keyword">let</span> eq x y = x * x = y * y 
  <span class="hljs-keyword">end</span>)

<span class="hljs-keyword">let</span> v0 = <span class="hljs-type">Coll</span>.empty <span class="hljs-type">S0</span>.eq 
<span class="hljs-keyword">let</span> v1 = <span class="hljs-type">Coll</span>.empty <span class="hljs-type">S1</span>.eq 

<span class="hljs-keyword">let</span> a0 = <span class="hljs-type">Coll</span>.add v0 <span class="hljs-number">1</span> 
<span class="hljs-keyword">let</span> a1 = <span class="hljs-type">Coll</span>.add v1 <span class="hljs-number">1</span> 
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">S0</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
});

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">S1</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">*</span> x <span class="hljs-operator">==</span> y <span class="hljs-operator">*</span> y;
});

<span class="hljs-keyword">let</span> v0 = <span class="hljs-module-identifier">Coll</span>.empty(<span class="hljs-module-identifier">S0</span>.eq);
<span class="hljs-keyword">let</span> v1 = <span class="hljs-module-identifier">Coll</span>.empty(<span class="hljs-module-identifier">S1</span>.eq);

<span class="hljs-keyword">let</span> a0 = <span class="hljs-module-identifier">Coll</span>.add(v0, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> a1 = <span class="hljs-module-identifier">Coll</span>.add(v1, <span class="hljs-number">1</span>);
</code></pre>
<p>In practice, we can make use of first class modules to get rid of functors from end users, which is saved for readers.</p>
<p>When we mix <code>a0</code> and <code>a1</code>, we will get a type error</p>
<pre><code class="hljs">File <span class="hljs-built_in">..</span>., line 71, characters 13-15:
Error: This expression has<span class="hljs-built_in"> type </span>(int, S1.identity) Coll.coll
       but an expression was expected of<span class="hljs-built_in"> type </span>(int, S0.identity) Coll.coll
      <span class="hljs-built_in"> Type </span>S1.identity is <span class="hljs-keyword">not</span> compatible with<span class="hljs-built_in"> type </span>S0.identity 
</code></pre>
<p>As you read here, by using such encoding, the data structure is more generalized from user point of view. The generated JS code is not in a big closure so that it can be dead code eliminated better.</p>
<p>This style is extensively used in Belt encoding, we  encourage you to have a look at its implementation for better ideas.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/09/23/release-5-20-0">Release 5.2.0/6.2.0</a></h1><p class="post-meta">September 23, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform</code> 5.2.0/6.2.0 is released, it contains several major enhancement that we would like to share with you.</p>
<p>You can install it via <code>npm i -g bs-platform@5.2.0</code></p>
<h1><a class="anchor" aria-hidden="true" id="local-module-compiled-into-object"></a><a href="#local-module-compiled-into-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local module compiled into object</h1>
<p>OCaml has an <a href="https://people.mpi-sws.org/~dreyer/thesis/old/thesis050405.pdf">advanced module system</a> for people to structure large scale applications, it supports first class module and higher-order module system which is unique compared to other ML-like languages such as F# and Haskell.</p>
<p>In previous versions, BuckleScript compiled local modules into a JS array whereby global modules (module produced by a file)were transformed into JS objects.</p>
<p>When a local module is compiled into a JS array, the field name is stripped away, which makes debugging and JS interop difficult. To make the debugging experience better, we instrumented the array with field names in debug mode, this mitigated the debugging issue, but still present challenges for JS interop.</p>
<p>In this release, the compiler generates uniform representation for global module and local module -- idiomatic JS object, this makes OCaml's module system more valuable to JS target.</p>
<p>Below is an image showing the diff in this release</p>
<p><img src="/img/functor.png"></p>
<p>As you can see, the <code>id</code> module changed from an array into an JS object.</p>
<h1><a class="anchor" aria-hidden="true" id="pattern-match-code-generation-with-annotations"></a><a href="#pattern-match-code-generation-with-annotations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern match code generation with annotations</h1>
<p>BuckleScript aims to generate readable code.</p>
<p>OCaml has a sophiscated pattern match compiler, it generates well optimized code, however, for complex pattern matching, the constructor name is lost on native backend, this is also one of the very few case where we generate magic number
in JS backend, this makes debugging particularly challenging for large complex pattern match.</p>
<p>In this release, we made such information available to JS backend so that we annotate the generated JS code with its names.</p>
<p>Below is an image showing the diff in this release</p>
<p><img src="/img/pattern-match.png"></p>
<p>In the future, we will explore if we can produce such annotation in the runtime without losing efficiency.</p>
<h1><a class="anchor" aria-hidden="true" id="code-generation-improvement-in-various-places"></a><a href="#code-generation-improvement-in-various-places" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code generation improvement in various places</h1>
<p>We care about the generated code quality, and will always keep improving it regardless how good it is.</p>
<p>In this release, we improved the code generation in quite a lot of places including lazy evaluation, if branches and pattern match.</p>
<p>In particular, we added a data-flow pass to eliminate non-necessary staticfail case.</p>
<p><img src="/img/staticfail.png"></p>
<h1><a class="anchor" aria-hidden="true" id="important-bug-fixes"></a><a href="#important-bug-fixes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Important bug fixes</h1>
<p>This release also comes with a couple of important bug fixes, in particular, #3805 the stale build issue and #3823 the interaction with reason langauge service.</p>
<h1><a class="anchor" aria-hidden="true" id="upcoming-breaking-changes"></a><a href="#upcoming-breaking-changes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Upcoming breaking changes</h1>
<p>In next release, we plan to <a href="https://reasonml.chat/t/ann-remove-deprecated-getters-in-deriving-abstract-after-5-2-0/1908">remove deprecated getters</a>.</p>
<p>A detailed list of changes is available <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#520">here</a></p>
<p>Happy hacking!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/blog/page2/">Next →</a></div></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>