<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A faster, simpler and more robust take on JavaScript."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/"/><meta property="og:description" content="A faster, simpler and more robust take on JavaScript."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2020/02/04/release-7-1-0">bs-platform release 7.1.0</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/12/27/whats-new-in-7-cont">What&#x27;s new in release 7 (cont)</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/12/20/release-7-02">BuckleScript holiday release!</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/11/18/whats-new-in-7">What&#x27;s new in release 7</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/10/16/another-encoding">Another way of encoding type identity for BuckleScript libraries without using big functor</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/04/release-7-1-0">bs-platform release 7.1.0</a></h1><p class="post-meta">February 4, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform@7.1.0</code> is a major release. You can try it with <code>npm i -g bs-platform</code>!
(If you have permission issues, try <code>sudo npm i --unsafe-perm -g bs-platform</code>)</p>
<p>It was called 7.0.2 but bumped into 7.1.0 due to a soundness fix (a breaking change) as follows:</p>
<p>Previously, the empty array <code>[||]</code> was polymorphic. This happens to be true, since in native an array is not resizable, so users cannot do anything with it. But in JS, we introduced a binding for <code>push</code> which can change the size of an array dynamically. In this case, an empty array cannot be polymorphic any more.</p>
<p>Removing <code>push</code> is possible, but it makes arrays in JS context less useful. To fix this issue while keeping <code>push</code>, we make <code>[||]</code> weakly typed so that its type inference is deferred until the first time it is used. If it is never used across the module, it has to be annotated with a concrete type; otherwise, the type checker will complain.</p>
<p>Several highlighted features are listed as follows:</p>
<h2><a class="anchor" aria-hidden="true" id="raw-javascript-parsing-checking"></a><a href="#raw-javascript-parsing-checking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Raw JavaScript Parsing/Checking</h2>
<p>BuckleScript allows users to embed raw JavaScript code as an escape hatch; it used to treat such piece of code as a black box.</p>
<p>In this release we vendor a JavaScript parser (thanks to <a href="https://github.com/facebook/flow">flowtype</a>) for syntax checking and simple semantics analysis over <code>raw</code>. This is on-going work, but it is already useful now.</p>
<p>First, we now report syntax errors properly for <code>raw</code>.</p>
<p>Second, for simple semantics analysis, we can tell whether the code inside raw is a function or not and the arity of raw function:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = [%raw <span class="hljs-string">"function(x){return x}"</span>]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw "function(x){return x}"]</span>;
</code></pre>
<p>Now we know <code>f</code> is a function declaration with no side effect; it can be removed by the dead code analyzer if not used. We also know its arity so that when it's called we know whether it's fully applied or not.</p>
<p>Because this sort of information can be derived from <code>raw</code> directly, the special <code>raw</code> form we introduced as follows is no longer needed:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">fun</span>%raw x -&gt; {|x|}
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw x =&gt; {|x|}]</span>;
</code></pre>
<p>To reduce interop API surface, this feature will now be discouraged.</p>
<p>We're also exploring using such knowledge on JS literals and regexes checking.</p>
<h2><a class="anchor" aria-hidden="true" id="unboxed-types"></a><a href="#unboxed-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unboxed Types</h2>
<p>One major feature introduced in this release is <strong>unboxed types</strong> which is blogged <a href="https://bucklescript.github.io/blog/2019/12/20/release-7-02">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="uniform-warning-system"></a><a href="#uniform-warning-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uniform Warning System</h2>
<p>Previously warnings are reported in two ways:</p>
<ul>
<li>The OCaml compiler style: <code>-w +10</code></li>
<li>Ad-hoc warnings introduced by flags <code>-bs-warn-unimplemented-external</code></li>
</ul>
<p>This unneeded complexity is due to the fact OCaml's own warning system can only handle warnings in the type checking pass, so warnings in parsing and code generation are not handled properly.</p>
<p>In this release, we make such integration more reliable so that warnings after parsing are handled in the same way. For example, the warning attribute below can now also turn off BuckleScript warnings.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@warning "-101"]</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> file<span class="hljs-operator">-</span>level config
</code></pre>
<p>Based on this effort, we have changed all BuckleScript warnings into OCaml style warnings to reduce user-level complexity.</p>
<p>The newly introduced warnings are listed via <code>bsc -warn-help</code>:</p>
<pre><code class="hljs"><span class="hljs-symbol">101 </span>BuckleScript warning: Unused bs attributes
<span class="hljs-symbol">102 </span>BuckleScript warning: polymorphic comparison introduced (maybe unsafe)
<span class="hljs-symbol">103 </span>BuckleScript warning: about fragile FFI definitions
<span class="hljs-symbol">104 </span>BuckleScript warning: bs.deriving warning with customized message
<span class="hljs-symbol">105 </span>BuckleScript warning: the external <span class="hljs-keyword">name</span> is inferred from <span class="hljs-keyword">val</span> <span class="hljs-keyword">name</span> is unsafe from refactoring when changing value <span class="hljs-keyword">name</span>
<span class="hljs-symbol">106 </span>BuckleScript warning: Unimplemented primitive used:
<span class="hljs-symbol">107 </span>BuckleScript warning: Integer literal exceeds the range of representable integers of type <span class="hljs-keyword">int</span>
<span class="hljs-symbol">108 </span>BuckleScript warning: Uninterpreted delimiters (<span class="hljs-keyword">for</span> unicode)
</code></pre>
<p>We also recommend users to turn on <code>warnerror</code> and only disable warnings for some specific files.</p>
<p>We've also upgraded the Reason parser <code>refmt</code> to 3.6.0.</p>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/27/whats-new-in-7-cont">What&#x27;s new in release 7 (cont)</a></h1><p class="post-meta">December 27, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>[EDIT pre Dec. 27th: yes, we know the dateline is wrong :-) the actual publish date of this post is November 28th, but we're not changing the dateline because that would break the published URL of the post.]</p>
<p>The second dev release <a href="https://github.com/BuckleScript/bucklescript/pull/3995">7.0.0-dev.2</a> is released for testing!</p>
<p>As we mentioned in the <a href="https://bucklescript.github.io/blog/2019/11/18/whats-new-in-7">previous post</a>, we compile records into js objects in this release. This makes the generated code more idiomatic, however, this is not enough to write idiomatic bindings to manipulate arbitrary js objects, since the key of js objects can be arbitrary which is not expressible in ReasonML syntax, so we support user level customization now, which makes idiomatic bindings really easy.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> entry = {
  <span class="hljs-attribute">[@bs.as "EXACT_MAPPING_TO_JS_LABEL"]</span>
  x: int,
  <span class="hljs-attribute">[@bs.as "EXACT_2"]</span>
  y: int,
  z: obj,
}
<span class="hljs-keyword">and</span> obj = {
  <span class="hljs-attribute">[@bs.as "hello"]</span>
  hi: int,
};

<span class="hljs-keyword">let</span> f4 = ({x, y, z: {hi}}) =&gt; (x <span class="hljs-operator">+</span> y <span class="hljs-operator">+</span> hi) <span class="hljs-operator">*</span> <span class="hljs-number">2</span>;

</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> entry  = {
  x : <span class="hljs-built_in">int</span>  ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_MAPPING_TO_JS_LABEL"</span>]
  y : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_2"</span>]
  z : obj
} 
<span class="hljs-keyword">and</span> obj = {
  hi : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"hello"</span>]  
}    

<span class="hljs-keyword">let</span> f4  { x; y; z = {hi }} = 
  (x + y + hi) * <span class="hljs-number">2</span>
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params">param</span>) </span>{
  <span class="hljs-keyword">return</span> (((param.EXACT_MAPPING_TO_JS_LABEL + param.EXACT_2 | <span class="hljs-number">0</span>) + param.z.hello | <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-number">1</span>);
}
</code></pre>
<p>As you can see, you can manipulate js objects using Reason pattern match syntax, the generated
code is highly efficient, more importantly, bindings to JS will be significantly simplifie.</p>
<p>Happy Hacking.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/20/release-7-02">BuckleScript holiday release!</a></h1><p class="post-meta">December 20, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://github.com/BuckleScript/bucklescript/pull/4062">bs-platform@7.0.2-dev.1</a> is released for testing!</p>
<p>Try it via</p>
<pre><code class="hljs"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">-g</span> <span class="hljs-selector-tag">bs-platform</span>@<span class="hljs-keyword">7</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">2</span>-<span class="hljs-keyword">dev</span>.<span class="hljs-keyword">1</span>
</code></pre>
<p>This release contains several bug fixes for <a href="https://github.com/facebook/reason">refmt</a>(updated from 3.5.1 to 3.5.4). We also spent quite some time improving the compiler performance. For example, we optimized our specialized hash based data structures, which means that we can expect a 5% better build time performance. We would like to collect more benchmark data, so we are happy for any feedback / benchmarks from our community!</p>
<p>A highlighting feature is that we added Generalized Unboxed Support (so called [@unboxed] annotations). Here's a short definition from the official OCaml Manual:</p>
<blockquote>
<p>unboxed can be used on a type definition if the type is a single-field record or a concrete type with a single constructor that has a single argument. It tells the compiler to optimize the representation of the type by removing the block that represents the record or the constructor (i.e. a value of this type is physically equal to its argument). In the case of GADTs, an additional restriction applies: the argument must not be an existential variable, represented by an existential type variable, or an abstract type constructor applied to an existential type variable.</p>
</blockquote>
<p><strong>Note</strong>: The beforementioned restriction about GADTs only applies to OCaml's native compiler, not to BuckleScript's JavaScript compilation. So we will get the maximum value with less confusing error messages!</p>
<p>The exciting thing about this feature is that we will now have more ways of expressing our programs in our typical type safe records and variants without sacrificing on runtime performance (&quot;zero cost interop&quot;).</p>
<p>The best way to understand this feature is by looking at the following examples:</p>
<p><strong>Unboxed variants:</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = <span class="hljs-constructor">A</span>(int);
<span class="hljs-keyword">let</span> x = <span class="hljs-constructor">A</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
</code></pre>
<p>As you can see, we are &quot;unboxing&quot; the <code>int</code> value from the internal variant representation, so the variant will get completely invisible to the runtime. Great for e.g. mapping to stringly typed JavaScript enums!</p>
<p><strong>Unboxed Records (1 field only)</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t2 = {f: string};
<span class="hljs-keyword">let</span> x = {f: <span class="hljs-string">"foo"</span>};
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">"foo"</span>;
</code></pre>
<p>The same principle as with variants. Now a lot of people will probably ask: &quot;Why would I ever want a 1 field record?&quot;. There are multiple reasons, one of them would be a <code>ref</code> type, which is just a syntax sugar for a <code>{ contents: 'a}</code> record.</p>
<p>Another use case is for expressing high rank polymorphism without cost:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> r = {f: 'a. 'a =&gt; 'a};
<span class="hljs-keyword">let</span> map_pair = (r, (p1, p2)) =&gt; (r.f(p1), r.f(p2));
</code></pre>
<p><strong>Note:</strong> <code>'a. 'a =&gt; 'a</code> describes a polymorphic function interface, where <code>'a</code> can be called with many different types (e.g. <code>f(1)</code> and <code>f(&quot;hi&quot;)</code>). The compiler will not try to lock <code>'a</code> for the first type it sees (e.g. the <code>int</code>) on the first call site. The parameter <code>'a</code> is therefore polymorphic!</p>
<p>By <code>unboxing</code> those records with one polymorphic function,  we will get rid of <a href="https://github.com/BuckleScript/bucklescript/issues/4058">value restriction for our existing encoding of uncurried function</a>, this will be a major feature!</p>
<p><strong>Unboxed GADTs:</strong></p>
<p>Since GADTs are lesser known in Reason syntax, we also added some OCaml snippet to get a better idea of how the example data structure is defined.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-constructor">Any</span> ('a) : t; 

<span class="hljs-keyword">let</span> array = <span class="hljs-literal">[|</span><span class="hljs-constructor">Any</span>(<span class="hljs-number">3</span>), <span class="hljs-constructor">Any</span>(<span class="hljs-string">"a"</span>)<span class="hljs-literal">|]</span>;
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
[@@unboxed]

<span class="hljs-keyword">let</span> <span class="hljs-built_in">array</span> = [|<span class="hljs-type">Any</span> <span class="hljs-number">3</span>; <span class="hljs-type">Any</span> <span class="hljs-string">"a"</span>|]
</code></pre>
<p>The examples above will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> array = [ <span class="hljs-number">3</span>, <span class="hljs-string">"a"</span>];
</code></pre>
<p>As you can already tell, this feature will give us way better possibilities to do interop with polymorphic array representations in JavaScript (without losing any type safetiness!).</p>
<p>As a more concrete use-case, this will give users the possibility to define types such as <code>int_or_string</code>.</p>
<p><strong>Note:</strong> Even if this GADT <code>t</code> contains an ADT <code>Any</code>, it doesn't mean that it's the same as <code>any</code> in TypeScript. An <code>Any</code> value is constrained to a certain contract (<code>'a -&gt; t</code>), the array <code>[|Any(3), Any(&quot;a&quot;)|]</code> is inferred as a <code>array(t)</code>. When users try to use <code>Any</code> values, they need to unpack them, process the value inside, and repack them again. Pretty neat, right?</p>
<h3><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>
<p>This release will introduce the <code>[@unbox]</code> annotation to give us better ways to do zero cost interop with variants, records, higher kinded polymorphic functions, and GADTs. Under the hood improvements will give us better performance as well!</p>
<p>We are really excited about these changes, and we hope so are you. Please check out our newest <code>bs-platform@7.0.2-dev.1</code> release and let us know if you find any issues!</p>
<p>A detailed list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
<p>Happy hacking!</p>
<h3><a class="anchor" aria-hidden="true" id="appendix"></a><a href="#appendix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appendix</h3>
<p><strong>A sophiscated explanation on why <code>unboxed</code> lifts some OCaml's type system limitations</strong></p>
<blockquote>
<p>structural types (objects, classes, polymorphic variants, functions, etc) in
OCaml are regular types, ocaml always do the expansion when dealing with such
types, there is some limitations for such structural types, for example, non
regular definitions are not allowed. Non structural types (variants, records)
does not have such limitations, with <code>unboxed</code>, we can use non structural
types as an indirection without changing its runtime representations.</p>
</blockquote>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/11/18/whats-new-in-7">What&#x27;s new in release 7</a></h1><p class="post-meta">November 18, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>The new major version of BuckleScript is coming -<a href="https://github.com/BuckleScript/bucklescript/pull/3968">7.0.0-dev.1</a> released for testing!</p>
<p>We are maintaining <code>5.*</code> and <code>6.*</code> for OCaml <code>4.02</code> and <code>4.06</code> for a while, since this release we are moving forward and focusing on release 7.* (for OCaml 4.06).</p>
<p>This is a major release comes with lots of nice features listed <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md">here</a>.</p>
<p>We talk about some highlights here</p>
<ul>
<li><p>refmt upgraded to latest, it comes with better error message</p></li>
<li><p>OCaml Records compiled into JS objects</p></li>
</ul>
<p>This is one of the most desired features, it is finally landed.</p>
<p>See the generated code below for excitement!</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> t = {
  x: <span class="hljs-built_in">int</span>,
  y: <span class="hljs-built_in">int</span>,
  z: <span class="hljs-built_in">int</span>,
};

<span class="hljs-keyword">let</span> obj = {x: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, z: <span class="hljs-number">2</span>};

<span class="hljs-keyword">let</span> obj2 = {...obj, y: <span class="hljs-number">4</span>};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t = {
  x : <span class="hljs-built_in">int</span>;
  y : <span class="hljs-built_in">int</span>;
  z : <span class="hljs-built_in">int</span> 
}

<span class="hljs-keyword">let</span> obj = { x = <span class="hljs-number">3</span> ; y = <span class="hljs-number">2</span>; z = <span class="hljs-number">2</span>}

<span class="hljs-keyword">let</span> obj2 = { obj <span class="hljs-keyword">with</span> y = <span class="hljs-number">4</span>}
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};
</code></pre>
<p>This new change makes record much more useful and its interaction with <code>private</code> type; unboxed option type will make interop with JS much nicer!</p>
<p>As always, we continue improving our optimizer in various <a href="https://github.com/BuckleScript/bucklescript/pull/3966/files?file-filters%5B%5D=.js">commits</a>, we belive that not only a better language but also an implementation of high quality is key to push typed functional programming into industry.</p>
<p>Happy hacking!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/10/16/another-encoding">Another way of encoding type identity for BuckleScript libraries without using big functor</a></h1><p class="post-meta">October 16, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>Note this article is for library authors, it has something in depth which is not necessary for people who use BuckleScript at daily work.</p>
<p>When we build some generic data structure, abstract over function is not enough. For example,  a type safe generic balanced AVL tree not only relies on the types of a comparison function, but also the identity of such function. Two balanced AVL trees which are initialized over same type of comparison function still can not be mixed.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Eq1</span> = {
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Eq1</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">let</span> eq x y = x = y
<span class="hljs-keyword">end</span> 
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Eq2</span> = {
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Eq2</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">let</span> eq x y = x * x = y * y 
<span class="hljs-keyword">end</span>
</code></pre>
<p>Take the two modules above for example, they have the same type, but we need a way to mark their identity so that data structures instantiated using them can not be mixed.</p>
<p>A traditional way is using functor:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> (<span class="hljs-type">Cmp</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> t 
  <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span>
<span class="hljs-keyword">end</span>) = 
(<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">open</span> <span class="hljs-type">Cmp</span>
  <span class="hljs-keyword">type</span> key = t
  <span class="hljs-keyword">type</span> coll = key <span class="hljs-built_in">list</span> 
  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[]</span>
  <span class="hljs-keyword">let</span> add  (y : coll) (e : key) = 
    <span class="hljs-keyword">if</span> <span class="hljs-type">List</span>.exists (<span class="hljs-keyword">fun</span> x -&gt; eq x e) y <span class="hljs-keyword">then</span>
      y
    <span class="hljs-keyword">else</span>      
      e::y
<span class="hljs-keyword">end</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> key = <span class="hljs-type">Cmp</span>.t 
  <span class="hljs-keyword">type</span> coll
  <span class="hljs-keyword">val</span> empty : coll
  <span class="hljs-keyword">val</span> add : coll -&gt; key -&gt; coll
<span class="hljs-keyword">end</span> )

<span class="hljs-keyword">module</span> <span class="hljs-type">Ins1</span> = <span class="hljs-type">Make</span>(<span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span> 
  <span class="hljs-keyword">let</span> eq x y = x = y 
<span class="hljs-keyword">end</span>)
<span class="hljs-keyword">module</span> <span class="hljs-type">Ins2</span> = <span class="hljs-type">Make</span>(<span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span> 
  <span class="hljs-keyword">let</span> eq x y = x * x = y * y
<span class="hljs-keyword">end</span>)
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span> = (
  <span class="hljs-module-identifier">Cmp</span>: {
    <span class="hljs-keyword">type</span> t;
    <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
  }) : {
 <span class="hljs-keyword">type</span> key = <span class="hljs-module-identifier">Cmp</span>.t;
 <span class="hljs-keyword">type</span> coll;
 <span class="hljs-keyword">let</span> empty: coll;
 <span class="hljs-keyword">let</span> add: (coll, key) =&gt; coll;
} =&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Cmp</span>;
  <span class="hljs-keyword">type</span> key = t;
  <span class="hljs-keyword">type</span> coll = list(key);
  <span class="hljs-keyword">let</span> empty = <span class="hljs-literal">[</span><span class="hljs-literal">]</span>;
  <span class="hljs-keyword">let</span> add = (y: coll, e: key) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">List</span>.exists(x =&gt; eq(x, e), y)) {
      y;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-literal">[</span>e, <span class="hljs-operator">...</span>y<span class="hljs-literal">]</span>;
    };
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Ins1</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
});
<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Ins2</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">*</span> x <span class="hljs-operator">==</span> y <span class="hljs-operator">*</span> y;
});
</code></pre>
<p>By marking <code>coll</code> as abstract type, when such functor is initialized,<code>Ins1.coll</code> and <code>Ins2.coll</code> are no longer the same.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> v = [<span class="hljs-type">Ins1</span>.empty; <span class="hljs-type">Ins2</span>.empty]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> v = <span class="hljs-literal">[</span><span class="hljs-module-identifier">Ins1</span>.empty, <span class="hljs-module-identifier">Ins2</span>.empty<span class="hljs-literal">]</span>;
</code></pre>
<p>When mixing them together, we get a type error</p>
<pre><code class="hljs">File <span class="hljs-built_in">..</span>., line 31, characters 21-31:
Error: This expression has<span class="hljs-built_in"> type </span>Ins2.coll
       but an expression was expected of<span class="hljs-built_in"> type </span>Ins1.coll
</code></pre>
<p>There are some issues with such encoding:</p>
<ul>
<li><p>From runtime point of view, <code>Ins1</code> is initialized during runtime, its implementation is a <em>big closure</em>, which means even if you only use on function in <code>Ins1</code> module, all functions will be linked in.</p></li>
<li><p>From user point of view, people has to call <code>Ins1.add</code> and <code>Ins2.add</code> instead of calling <code>Ins.add</code>, this makes code less polymorphic.</p></li>
</ul>
<p>Now we introduce another encoding, note it is quite sophiscated that is recommended only for library authors</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Cmp</span>: {
  <span class="hljs-keyword">type</span> cmp('a, 'id);
  <span class="hljs-keyword">let</span> eq: (cmp('a, 'id), 'a, 'a) =&gt; bool;
  <span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span>: (
    <span class="hljs-constructor">M</span>: {
       <span class="hljs-keyword">type</span> t;
       <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
     }
  ) =&gt; {
    <span class="hljs-keyword">type</span> identity;
    <span class="hljs-keyword">let</span> eq: cmp(<span class="hljs-module-identifier">M</span>.t, identity);
  };
} = {
  <span class="hljs-keyword">type</span> cmp('a, 'id) = ('a, 'a) =&gt; bool;
  <span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Make</span> = (
    <span class="hljs-module-identifier">M</span>: {
     <span class="hljs-keyword">type</span> t;
     <span class="hljs-keyword">let</span> eq: (t, t) =&gt; bool;
    }
  ) =&gt; {
    <span class="hljs-keyword">type</span> identity;
    <span class="hljs-keyword">include</span> <span class="hljs-module-identifier">M</span>;
  };
  <span class="hljs-keyword">let</span> eq = (cmp, x, y) =&gt; cmp(x, y); <span class="hljs-comment">/* This could be inlined by using externals */</span>
};

<span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Cmp</span>;

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Coll</span>: {
  <span class="hljs-keyword">type</span> coll('k, 'id);
  <span class="hljs-keyword">let</span> empty: cmp('k, 'id) =&gt; coll('k, 'id);
  <span class="hljs-keyword">let</span> add: (coll('k, 'id), 'k) =&gt; coll('k, 'id);
} = {
  <span class="hljs-keyword">type</span> coll('k, 'id) = {
    eq: cmp('k, 'id),
    data: list('k),
  };

  <span class="hljs-keyword">let</span> empty = (<span class="hljs-keyword">type</span> t, <span class="hljs-keyword">type</span> identity, eq: cmp(t, identity)) =&gt; {
    data: <span class="hljs-literal">[</span><span class="hljs-literal">]</span>,
    eq,
  };
  <span class="hljs-keyword">let</span> add = (x: coll('k, 'id), y: 'k) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">List</span>.exists(a =&gt; <span class="hljs-module-identifier">Cmp</span>.eq(x.eq, a, y), x.data)) {
      x;
    } <span class="hljs-keyword">else</span> {
      {
        data: <span class="hljs-literal">[</span>y, <span class="hljs-operator">...</span>x.data<span class="hljs-literal">]</span>,
        eq: x.eq,
      };
    };
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Cmp</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'id</span>) cmp 
  <span class="hljs-keyword">val</span> eq : (<span class="hljs-symbol">'a</span>,<span class="hljs-symbol">'id</span>) cmp -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">bool</span>
  <span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> : <span class="hljs-keyword">functor</span> (<span class="hljs-type">M</span> : 
    <span class="hljs-keyword">sig</span> <span class="hljs-keyword">type</span> t 
      <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span> 
    <span class="hljs-keyword">end</span>
  ) -&gt; <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> identity
    <span class="hljs-keyword">val</span> eq :  (<span class="hljs-type">M</span>.t, identity) cmp
  <span class="hljs-keyword">end</span> 

<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'id</span>) cmp = <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">bool</span>
  <span class="hljs-keyword">module</span> <span class="hljs-type">Make</span> (<span class="hljs-type">M</span>: <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">val</span> eq : t -&gt; t -&gt; <span class="hljs-built_in">bool</span>  
  <span class="hljs-keyword">end</span>) = <span class="hljs-keyword">struct</span> 
    <span class="hljs-keyword">type</span> identity
    <span class="hljs-keyword">include</span> <span class="hljs-type">M</span>
  <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">let</span> eq cmp x y = cmp x y <span class="hljs-comment">(* This could be inlined by using externals *)</span>
<span class="hljs-keyword">end</span> 

<span class="hljs-keyword">open</span> <span class="hljs-type">Cmp</span> 

<span class="hljs-keyword">module</span> <span class="hljs-type">Coll</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll
  <span class="hljs-keyword">val</span> empty : (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) cmp -&gt; (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) coll
  <span class="hljs-keyword">val</span> add : (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll -&gt; <span class="hljs-symbol">'k</span> -&gt; (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) coll 
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'k</span>, <span class="hljs-symbol">'id</span>) coll = {
    eq :   (<span class="hljs-symbol">'k</span>,<span class="hljs-symbol">'id</span>) cmp;
    data :  <span class="hljs-symbol">'k</span> <span class="hljs-built_in">list</span> 
  }

  <span class="hljs-keyword">let</span> empty (<span class="hljs-keyword">type</span> t) (<span class="hljs-keyword">type</span> identity) (eq : (t,identity) cmp) = {
    data = <span class="hljs-literal">[]</span>;
    eq = eq 
  }

  <span class="hljs-keyword">let</span> add (x : (<span class="hljs-symbol">'k</span>,<span class="hljs-string">' id) coll) (y : '</span>k) =  
    <span class="hljs-keyword">if</span> <span class="hljs-type">List</span>.exists (<span class="hljs-keyword">fun</span> a -&gt; <span class="hljs-type">Cmp</span>.eq x.eq a y) x.data <span class="hljs-keyword">then</span> x
    <span class="hljs-keyword">else</span> {
      data = y:: x.data;
      eq = x.eq 
    }
<span class="hljs-keyword">end</span> 

</code></pre>
<p>The key is the construction of Cmp modules, we create an abstract type <code>cmp</code> which is signed by a phantom type as its identity, it is unique whenever user create it by calling <code>Make</code> functor. Here we are still using functor, but it is small functor.</p>
<p>The usage is as below:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">S0</span> = <span class="hljs-type">Make</span> (<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span>
    <span class="hljs-keyword">let</span> eq x y = x = y
  <span class="hljs-keyword">end</span>)

<span class="hljs-keyword">module</span> <span class="hljs-type">S1</span> = <span class="hljs-type">Make</span> (<span class="hljs-keyword">struct</span> 
  <span class="hljs-keyword">type</span> t  = <span class="hljs-built_in">int</span>
    <span class="hljs-keyword">let</span> eq x y = x * x = y * y 
  <span class="hljs-keyword">end</span>)

<span class="hljs-keyword">let</span> v0 = <span class="hljs-type">Coll</span>.empty <span class="hljs-type">S0</span>.eq 
<span class="hljs-keyword">let</span> v1 = <span class="hljs-type">Coll</span>.empty <span class="hljs-type">S1</span>.eq 

<span class="hljs-keyword">let</span> a0 = <span class="hljs-type">Coll</span>.add v0 <span class="hljs-number">1</span> 
<span class="hljs-keyword">let</span> a1 = <span class="hljs-type">Coll</span>.add v1 <span class="hljs-number">1</span> 
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">S0</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">==</span> y;
});

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">S1</span> = <span class="hljs-module-identifier">Make</span>({
  <span class="hljs-keyword">type</span> t = int;
  <span class="hljs-keyword">let</span> eq = (x, y) =&gt; x <span class="hljs-operator">*</span> x <span class="hljs-operator">==</span> y <span class="hljs-operator">*</span> y;
});

<span class="hljs-keyword">let</span> v0 = <span class="hljs-module-identifier">Coll</span>.empty(<span class="hljs-module-identifier">S0</span>.eq);
<span class="hljs-keyword">let</span> v1 = <span class="hljs-module-identifier">Coll</span>.empty(<span class="hljs-module-identifier">S1</span>.eq);

<span class="hljs-keyword">let</span> a0 = <span class="hljs-module-identifier">Coll</span>.add(v0, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> a1 = <span class="hljs-module-identifier">Coll</span>.add(v1, <span class="hljs-number">1</span>);
</code></pre>
<p>In practice, we can make use of first class modules to get rid of functors from end users, which is saved for readers.</p>
<p>When we mix <code>a0</code> and <code>a1</code>, we will get a type error</p>
<pre><code class="hljs">File <span class="hljs-built_in">..</span>., line 71, characters 13-15:
Error: This expression has<span class="hljs-built_in"> type </span>(int, S1.identity) Coll.coll
       but an expression was expected of<span class="hljs-built_in"> type </span>(int, S0.identity) Coll.coll
      <span class="hljs-built_in"> Type </span>S1.identity is <span class="hljs-keyword">not</span> compatible with<span class="hljs-built_in"> type </span>S0.identity 
</code></pre>
<p>As you read here, by using such encoding, the data structure is more generalized from user point of view. The generated JS code is not in a big closure so that it can be dead code eliminated better.</p>
<p>This style is extensively used in Belt encoding, we  encourage you to have a look at its implementation for better ideas.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/09/23/release-5-20-0">Release 5.2.0/6.2.0</a></h1><p class="post-meta">September 23, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform</code> 5.2.0/6.2.0 is released, it contains several major enhancement that we would like to share with you.</p>
<p>You can install it via <code>npm i -g bs-platform@5.2.0</code></p>
<h1><a class="anchor" aria-hidden="true" id="local-module-compiled-into-object"></a><a href="#local-module-compiled-into-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local module compiled into object</h1>
<p>OCaml has an <a href="https://people.mpi-sws.org/~dreyer/thesis/old/thesis050405.pdf">advanced module system</a> for people to structure large scale applications, it supports first class module and higher-order module system which is unique compared to other ML-like languages such as F# and Haskell.</p>
<p>In previous versions, BuckleScript compiled local modules into a JS array whereby global modules (module produced by a file)were transformed into JS objects.</p>
<p>When a local module is compiled into a JS array, the field name is stripped away, which makes debugging and JS interop difficult. To make the debugging experience better, we instrumented the array with field names in debug mode, this mitigated the debugging issue, but still present challenges for JS interop.</p>
<p>In this release, the compiler generates uniform representation for global module and local module -- idiomatic JS object, this makes OCaml's module system more valuable to JS target.</p>
<p>Below is an image showing the diff in this release</p>
<p><img src="/img/functor.png"></p>
<p>As you can see, the <code>id</code> module changed from an array into an JS object.</p>
<h1><a class="anchor" aria-hidden="true" id="pattern-match-code-generation-with-annotations"></a><a href="#pattern-match-code-generation-with-annotations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern match code generation with annotations</h1>
<p>BuckleScript aims to generate readable code.</p>
<p>OCaml has a sophiscated pattern match compiler, it generates well optimized code, however, for complex pattern matching, the constructor name is lost on native backend, this is also one of the very few case where we generate magic number
in JS backend, this makes debugging particularly challenging for large complex pattern match.</p>
<p>In this release, we made such information available to JS backend so that we annotate the generated JS code with its names.</p>
<p>Below is an image showing the diff in this release</p>
<p><img src="/img/pattern-match.png"></p>
<p>In the future, we will explore if we can produce such annotation in the runtime without losing efficiency.</p>
<h1><a class="anchor" aria-hidden="true" id="code-generation-improvement-in-various-places"></a><a href="#code-generation-improvement-in-various-places" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code generation improvement in various places</h1>
<p>We care about the generated code quality, and will always keep improving it regardless how good it is.</p>
<p>In this release, we improved the code generation in quite a lot of places including lazy evaluation, if branches and pattern match.</p>
<p>In particular, we added a data-flow pass to eliminate non-necessary staticfail case.</p>
<p><img src="/img/staticfail.png"></p>
<h1><a class="anchor" aria-hidden="true" id="important-bug-fixes"></a><a href="#important-bug-fixes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Important bug fixes</h1>
<p>This release also comes with a couple of important bug fixes, in particular, #3805 the stale build issue and #3823 the interaction with reason langauge service.</p>
<h1><a class="anchor" aria-hidden="true" id="upcoming-breaking-changes"></a><a href="#upcoming-breaking-changes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Upcoming breaking changes</h1>
<p>In next release, we plan to <a href="https://reasonml.chat/t/ann-remove-deprecated-getters-in-deriving-abstract-after-5-2-0/1908">remove deprecated getters</a>.</p>
<p>A detailed list of changes is available <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#520">here</a></p>
<p>Happy hacking!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/08/12/release-5-10-0">What&#x27;s new in release 5.1.0</a></h1><p class="post-meta">August 12, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform</code> 5.1.0 (for OCaml 4.02.3) and 6.1.0 (for OCaml 4.06.1) is ready for testing.</p>
<p>You can install it via <code>npm i -g bs-platform@5.1.0</code> (or <code>npm i -g bs-platform@6.1.0-dev.6</code>).</p>
<p>A detailed list of changes is available <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#510">here</a></p>
<p>Some feature enhancements are described as follows:</p>
<h2><a class="anchor" aria-hidden="true" id="introducing-bsc-to-public"></a><a href="#introducing-bsc-to-public" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introducing <code>bsc</code> to public</h2>
<p><code>bsc</code> is the underlying compiler which is invoked by <code>bsb</code>. In this release we simplified it a bit so that it can be used directly by customers for simple tasks. It is available after you have <code>bs-platform</code> installed.</p>
<p>Suppose you have a file called <code>test.re</code>:</p>
<pre><code class="hljs">let rec fib (n) = <span class="hljs-keyword">switch</span> n {
    | <span class="hljs-number">0</span> | <span class="hljs-number">1</span> =&gt; <span class="hljs-number">1</span>;
    | n =&gt; fib (n <span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);
};
Js.log (fib (<span class="hljs-number">0</span>));
</code></pre>
<p>You can compile it directly via <code>bsc test.re</code>, producing the following output:</p>
<pre><code class="hljs">bucklescript.github.io&gt;bsc test.re
<span class="hljs-comment">// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span> || n === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span> | <span class="hljs-number">0</span>) + fib(n - <span class="hljs-number">2</span> | <span class="hljs-number">0</span>) | <span class="hljs-number">0</span>;
  }
}
<span class="hljs-built_in">console</span>.log(fib(<span class="hljs-number">0</span>));
exports.fib = fib;
<span class="hljs-comment">/*  Not a pure module */</span>
</code></pre>
<p>You can also get the inferred signature directly via <code>bsc -i test.re</code></p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> fib: <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>;
</code></pre>
<p>Or even better, you can do a one liner in bsc, via <code>-e</code> option.</p>
<pre><code class="hljs">bucklescript&gt;bsc -i -e <span class="hljs-symbol">'let</span> id = x =&gt; x'
<span class="hljs-keyword">let</span> id: <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-symbol">'a</span>;
</code></pre>
<p>Note: <code>bsc</code> supports vanilla OCaml syntax as well, this is only recommended for toying around, for serious development, <code>bsb</code> is recommended.</p>
<h2><a class="anchor" aria-hidden="true" id="bstracing-to-visualize-build-profile"></a><a href="#bstracing-to-visualize-build-profile" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>bstracing</code> to visualize build profile</h2>
<p>After you finish the build process, you can run <code>bstracing</code> directly. This generates a data file called <code>tracing_${hour}_${minute}_${second}.json</code> which can be loaded into chrome via <code>chrome://tracing</code>.</p>
<p>Below is a profile image that shows the tracing graph for a large project:</p>
<p><img src="/img/profile-1.png"></p>
<p>And you can zoom-in to see more details:</p>
<p><img src="/img/profile-2.png"></p>
<h2><a class="anchor" aria-hidden="true" id="support-of-ppx-with-arguments"></a><a href="#support-of-ppx-with-arguments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Support of ppx with arguments</h2>
<p>We extended the schema to support ppx with arguments:</p>
<pre><code class="hljs css language-js">        <span class="hljs-string">"ppx-specs"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"array"</span>,
            <span class="hljs-string">"items"</span>: {
                <span class="hljs-string">"oneOf"</span> : [
                    {
                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span> <span class="hljs-comment">// single command</span>
                    },
                    {
                        <span class="hljs-string">"type"</span> : <span class="hljs-string">"array"</span>, <span class="hljs-comment">// command with args</span>
                        <span class="hljs-string">"items"</span>: {
                            <span class="hljs-string">"type"</span> : <span class="hljs-string">"string"</span> 
                        }
                    }
                ]
            }
        },
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="respect-node_path-when-resolving-dependent-modules"></a><a href="#respect-node_path-when-resolving-dependent-modules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Respect NODE_PATH when resolving dependent modules</h2>
<p>Previously, <code>bsb</code> was tied to npm package structures by searching <code>node_modules</code>. In this release, <code>bsb</code> also tries to search paths listed in <code>NODE_PATH</code> so that <code>bsb</code> is no longer tied to the npm or yarn package manager.</p>
<h2><a class="anchor" aria-hidden="true" id="build-performance-improvement"></a><a href="#build-performance-improvement" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Build performance improvement</h2>
<p>Yes, performance is increased with each release!</p>
<p>Quite a lot of work was spent in house-keeping this release. We changed the internal data representation to a more compact format. Here is the result of using <code>bstracing</code> to show a comparison of clean building a large project around (2 * 5 * 5 * 5 * 5 = 1250 files):</p>
<p>Version 5.0.6 (around 4.8s)</p>
<p><img src="/img/profile-5.png"></p>
<p>Version 5.1.0 (around 4.2s)</p>
<p><img src="/img/profile-4.png"></p>
<p>Happy hacking!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/06/26/release-5-0-5">Release 5.0.5 and 6.0.2</a></h1><p class="post-meta">June 26, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform</code> 5.0.5 (for OCaml 4.02.3) and 6.0.2 (for OCaml 4.06.1) is released.</p>
<p>A detailed list of changes is available <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#505">here</a></p>
<p>It has some critical bug fixes that we suggest users to upgrade.</p>
<p>Some feature enhancement is described as below:</p>
<h2><a class="anchor" aria-hidden="true" id="user-land-c-stubs-polyfill"></a><a href="#user-land-c-stubs-polyfill" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>User land C stubs polyfill</h2>
<p>Previously, for existing OCaml libraries which rely on some C primitives, it has to be patched in source level. In this release, user can provide such support independently without patching the source code.</p>
<p>Suppose you have an OCaml module which relies on an C primitive as below:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">external</span> ff : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">"caml_fancy_add"</span> 
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">external</span> ff : (int,int) =&gt; int = <span class="hljs-string">"caml_fancy_add"</span> ;
</code></pre>
<p><code>caml_fancy_add</code> is a C function for native code, now we can provide this support in a js files, what user needs to do is adding <code>caml_fancy_add</code> to a global variable like this</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">/**
 * @param {int} x 
 * @param {int} y
 * @returns {int}
 * 
 */</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'bs-platform/lib/js/caml_external_polyfill.js'</span>).register(<span class="hljs-string">'caml_fancy_add'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)</span>{
  <span class="hljs-keyword">return</span> + ((<span class="hljs-string">""</span>+x ) + (<span class="hljs-string">""</span>+y))
})
</code></pre>
<p>Note this is an experimental feature that we don't suggest users to use it extensively, it is provided as an escape hatch. We are also expecting feedback to see how we could improve it, so there might be some backward incompatible changes.</p>
<h2><a class="anchor" aria-hidden="true" id="a-new-warning-number-105"></a><a href="#a-new-warning-number-105" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A new warning number 105</h2>
<p>Previously, there are some scenarios that the Js function name is inferred during the interop.</p>
<p>For example</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">external</span> f : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.val]</span> <span class="hljs-keyword">external</span> f : int =&gt; int = <span class="hljs-string">""</span> 
</code></pre>
<p>Here the JS function name is inferred as <code>f</code> which is the same as OCaml function name.</p>
<p>Such ffi declaration is fragile to refactoring when changing names of f, it will also change the name of js function name which is probably not what user expected.</p>
<p>105 warning number is to help warn against this case (turned on by default).</p>
<h2><a class="anchor" aria-hidden="true" id="simplified-debugger-mode"></a><a href="#simplified-debugger-mode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simplified debugger mode</h2>
<p>Previously, user has to add <code>-bs-g</code> flag to <code>bsc-flags</code> in <code>bsconfig.json</code> and add one line code to the main module. Such code change is no longer needed, only the flag is needed.</p>
<h2><a class="anchor" aria-hidden="true" id="build-performance-improvement"></a><a href="#build-performance-improvement" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Build performance improvement</h2>
<p>We improved the build performance and simplified the design of the build significantly in this release, we will have a separate post about it.</p>
<p>Happy hacking!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/05/21/ffi-overview">A high level overview of BuckleScript interop with Javascript</a></h1><p class="post-meta">May 21, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>When users start to use BuckleScript to develop applications on JS platform, they have to interop with various APIs provided by the JS platform.</p>
<p>In theory, like <a href="https://elm-lang.org/">Elm</a>, BuckleScript could ship a comprehensive library which contains what most people would like to use daily.
This, however, is particularly challenging, given that
JS is running on so many platforms for example, <a href="https://electronjs.org/">Electron</a>, <a href="https://nodejs.org/">Node</a> and Browser, yet each platform is still evolving quickly. So we have to provide a mechanism to allow users to bind to the native JS API quickly in userland.</p>
<p>There are lots of trade-off when designing such a FFI bridge between OCaml and the JavaScript API. Below, we list a few key items which we think have an important impact on our design.</p>
<h2><a class="anchor" aria-hidden="true" id="interop-design-constraints"></a><a href="#interop-design-constraints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop design constraints</h2>
<ul>
<li><p>BuckleScript is still OCaml</p>
<p>We are not inventing a new language. In particular, we can not change the concrete syntax of OCaml. Luckily, OCaml introduced <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec260">attributes</a> and <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec262">extension nodes</a> since 4.02, which allows us to customize the language to a minor extent. To be a good citizen in the OCaml community, all attributes introduced by BuckleScript are prefixed with <code>bs</code>.</p></li>
<li><p>Bare metal efficiency should always be possible for experts in pure OCaml</p>
<p>Efficiency is at the heart of BuckleScript's design philosophy, in terms of both compilation speed and runtime performance. While there were other strongly typed functional languages running on the JS platform before we made BuckleScript, one thing in particular that confused me was that in those languages, people have to write <code>native JS</code> to gain performance. Our goal is that when performance really matters, it is still possible for experts to write pure OCaml without digging into <code>native JS</code>, so users don't have to make a choice between performance and type safety.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="easy-interop-using-raw-js"></a><a href="#easy-interop-using-raw-js" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Easy interop using raw JS</h2>
<p>BuckleScript allows users to insert raw JS using extension nodes directly. Please refer to the <a href="https://bucklescript.github.io/docs/en/embed-raw-javascript">documentation</a> for details. Here we only talk about one of the most used styles: inserting raw JS code as a function.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> getSafe : <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span>%raw a b -&gt; {| 
    <span class="hljs-keyword">if</span> (b&gt;=<span class="hljs-number">0</span> &amp;&amp; b &lt; a.length) {
        return a [b]
     }
     throw <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"out of range"</span>)
  |} 

<span class="hljs-keyword">let</span> v = getSafe [|<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>|] (-<span class="hljs-number">1</span>)
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> getSafe: (array(int), int) =&gt; int = <span class="hljs-attribute">[%raw
  (a, b) =&gt; {|
    if (b&gt;=0 &amp;&amp; b &lt; a.length) {
        return a [b]</span>
     }
     throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error</span>(<span class="hljs-string">"out of range"</span>)
  |}
<span class="hljs-literal">]</span>;

<span class="hljs-keyword">let</span> v = <span class="hljs-literal">[|</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><span class="hljs-literal">|]</span><span class="hljs-operator">-&gt;</span>getSafe<span class="hljs-number">(-1)</span>;
</code></pre>
<p>Here the raw extension node asks the user to list the parameters and function statement in raw JS syntax. The generated JS code is as follows:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSafe</span> (<span class="hljs-params">a,b</span>)</span>{ 
    <span class="hljs-keyword">if</span> (b&gt;=<span class="hljs-number">0</span> &amp;&amp; b &lt; a.length) {
        <span class="hljs-keyword">return</span> a [b]
     }
     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"out of range"</span>)
  };

<span class="hljs-keyword">var</span> v = getSafe(<span class="hljs-comment">/* array */</span>[
      <span class="hljs-number">1</span>,
      <span class="hljs-number">2</span>,
      <span class="hljs-number">3</span>
    ], <span class="hljs-number">-1</span>);

</code></pre>
<p>Inserting raw JS code as a function has several advantages:</p>
<ul>
<li>It is relatively safe; there is no variable name polluting.</li>
<li>It is quite expressive since the user can express everything inside the function body.</li>
<li>The compiler still has some knowledge about the function, for example, its arity.</li>
</ul>
<p>Some advice about using this style:</p>
<ul>
<li>Always annotate the raw function with explicit type annotation.</li>
<li>When annotating raw JS, you can use polymorphic types, but don’t create them when you don’t really need them. In general, non polymoprhic type is safer and more efficient.</li>
<li>Write a unit test for the function.</li>
</ul>
<p>Note that a nice thing about this mechanism is that no separate JS file is needed, so no change to the build system is necessary in most cases. By using this mechanism, BuckleScript users can already deal with most bindings.</p>
<h2><a class="anchor" aria-hidden="true" id="interop-via-attributes"></a><a href="#interop-via-attributes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop via attributes</h2>
<p>If you are a developer busy shipping, the mechanism above should cover almost everything you need. A minor disadvange of that mechanism is that it comes with a cost: a raw function can not be inlined since it is JavaScript, so the BuckleScript compiler does not have a deep knowledge about the function.</p>
<p>To demonstrate interop via attributes, we are going to show a small example of binding to JS <code>date</code>. There are lots of advanced topics in the <a href="https://bucklescript.github.io/docs/en/interop-overview">documentation</a>; here we are only talking about one of the most-used methods for interop.</p>
<p>The key idea is to bind your JS object as <a href="https://en.wikipedia.org/wiki/Abstract_data_type">an abstract data type</a> where a data type is defined by its behavior from the point of view of a user of the data, instead of the data type’s concrete representations.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> date
<span class="hljs-keyword">external</span> fromFloat : <span class="hljs-built_in">float</span> -&gt; date = <span class="hljs-string">"Date"</span> [@@bs.<span class="hljs-keyword">new</span>]
<span class="hljs-keyword">external</span> getDate : date -&gt; <span class="hljs-built_in">float</span> = <span class="hljs-string">"getDate"</span> [@@bs.send]
<span class="hljs-keyword">external</span> setDate : date -&gt; <span class="hljs-built_in">float</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"setDate"</span> [@@bs.send]

<span class="hljs-keyword">let</span> date = fromFloat <span class="hljs-number">10000.</span>
<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = setDate date <span class="hljs-number">3.</span>
<span class="hljs-keyword">let</span> d = getDate date
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> date;

<span class="hljs-attribute">[@bs.new]</span>
<span class="hljs-keyword">external</span> fromFloat : float =&gt; date = <span class="hljs-string">"Date"</span> ;
<span class="hljs-attribute">[@bs.send]</span>
<span class="hljs-keyword">external</span> getDate : date =&gt; float = <span class="hljs-string">"getDate"</span> ;
<span class="hljs-attribute">[@bs.send]</span>
<span class="hljs-keyword">external</span> setDate : date =&gt; float =&gt; unit = <span class="hljs-string">"setDate"</span>;

<span class="hljs-keyword">let</span> date = fromFloat (<span class="hljs-number">10000.0</span>);
date<span class="hljs-operator">-&gt;</span>setDate (<span class="hljs-number">3.0</span>);
<span class="hljs-keyword">let</span> d = date <span class="hljs-operator">-&gt;</span> getDate;
</code></pre>
<p>The preceding code generates the following JS. As you can see, the binding itself is zero cost and serves as formal documentation.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">10000</span>);
date.setDate(<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> d = date.getDate();
</code></pre>
<p>A typical workflow is that we create an abstract data type, create bindings for a “maker” using <code>bs.new</code>, and bind methods using <code>bs.send</code>.</p>
<p>Thanks to native support of abstract data types in OCaml, the interop is easy to reason about.</p>
<p>Some advice when using this style:</p>
<ul>
<li>Again, you can use polymorphic types in your annotations, but don't create polymorphic types when you don't need them.</li>
<li>Write a unit test for each external.</li>
</ul>
<p>As a comparison, we can create the same binding using <code>raw</code>:</p>
<pre><code class="hljs css language-ocaml">type date
let fromFloat : float -&gt; date = fun%raw d -&gt; {|return new Date(d)|}
let getDate : date -&gt; float = fun%raw d -&gt; {|return d.getDate()|}
let setDate : date -&gt; float -&gt; unit = fun%raw d v -&gt; {|
   d.setDate(v);
   return 0; // ocaml representation of unit 
|}

let date = fromFloat 10000.
let () = setDate date 3.
let d = getDate date
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> date;
<span class="hljs-keyword">let</span> fromFloat: float =&gt; date = <span class="hljs-attribute">[%raw d =&gt; {|return new Date(d)|}]</span>;
<span class="hljs-keyword">let</span> getDate: date =&gt; float = <span class="hljs-attribute">[%raw d =&gt; {|return d.getDate()|}]</span>;
<span class="hljs-keyword">let</span> setDate: (date, float) =&gt; unit = <span class="hljs-attribute">[%raw
  (d, v) =&gt; {|
   d.setDate(v);
   return 0; // ocaml representation of unit
|}
]</span>;

<span class="hljs-keyword">let</span> date = fromFloat(<span class="hljs-number">10000.</span>);
date<span class="hljs-operator">-&gt;</span>setDate( <span class="hljs-number">3.</span>);
<span class="hljs-keyword">let</span> d = date<span class="hljs-operator">-&gt;</span>getDate;

</code></pre>
<p>The generated JS is as follows, and you can see the cost:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromFloat</span> (<span class="hljs-params">d</span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(d)};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span> (<span class="hljs-params">d</span>)</span>{<span class="hljs-keyword">return</span> d.getDate()};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDate</span> (<span class="hljs-params">d,v</span>)</span>{
   d.setDate(v);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// ocaml representation of unit </span>
};

<span class="hljs-keyword">var</span> date = fromFloat(<span class="hljs-number">10000</span>);

setDate(date, <span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> d = getDate(date);
</code></pre>
<!-- ,  and provide various methods over such abstract data type. -->
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/04/22/release-5-0-4">architecture changes in bs-platform v5.0.4 and v6.0.1</a></h1><p class="post-meta">April 22, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>We are going to make releases of bs-platform@5.0.4 and bs-platform@6.0.1, this release mostly contains bug fixes.</p>
<p>At the same time, we are introducing an internal change which should be fine for average users.</p>
<p>If you are tooling authors, here are some details: previously we ship react_jsx ppx as a stand-alone binary, for example, reactjs_jsx_ppx_v2.exe, reactjs_jsx_ppx_v2.exe. Recently we start more close integration with <a href="https://reasonml.github.io">reason</a>, so it is absorbed into bsc.exe itself, we introduced a flag to have react-jsx on/off (note these are internal flags, not expected to be exposed to average users):</p>
<pre><code class="hljs"><span class="hljs-keyword">bsc.exe </span>-<span class="hljs-keyword">bs-jsx </span><span class="hljs-number">2</span> <span class="hljs-comment"># turn on reactjs_jsx_ppx_v2</span>
<span class="hljs-keyword">bsc.exe </span>-<span class="hljs-keyword">bs-jsx </span><span class="hljs-number">3</span> <span class="hljs-comment"># turn on reactjs_jsx_ppx_v3</span>
</code></pre>
<p>Like before, we also ship a stand alone bsppx.exe, it now absorbs reactjs_jsx_ppx as well.</p>
<pre><code class="hljs"><span class="hljs-keyword">bsppx.exe </span>-<span class="hljs-keyword">bs-jsx </span><span class="hljs-number">2</span> <span class="hljs-comment"># turn on reactjs_jsx_ppx_v2</span>
<span class="hljs-keyword">bsppx.exe </span>-<span class="hljs-keyword">bs-jsx </span><span class="hljs-number">3</span> <span class="hljs-comment"># turn on reactjs_jsx_ppx_v3</span>
</code></pre>
<p>The benefit of this change is that it help reduced the prebuilt binary size significantly and it also help shave 5~10ms per file compilation.</p>
<p>Another minor change we added, is that we introduced an env variable <code>BS_VSCODE</code> to help error messages more adapted to VsCode, see <a href="https://bucklescript.github.io/docs/en/build-configuration#bs-vscode-error-output-adapted-for-vscode">here</a> for more details.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/blog/page2/">Next →</a></div></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>