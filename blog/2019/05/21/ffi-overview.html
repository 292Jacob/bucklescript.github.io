<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>A high level overview of BuckleScript interop with Javascript · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="When users start to use BuckleScript to develop applications on JS platform, they have to interop with various APIs provided by the JS platform. "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="A high level overview of BuckleScript interop with Javascript · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/blog/2019/05/21/ffi-overview"/><meta property="og:description" content="When users start to use BuckleScript to develop applications on JS platform, they have to interop with various APIs provided by the JS platform. "/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul><li class="navListItem navListItemActive"><a class="navItem" href="/blog/2019/05/21/ffi-overview">A high level overview of BuckleScript interop with Javascript</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/04/22/release-5-0-4">architecture changes in bs-platform v5.0.4 and v6.0.1</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/04/09/release-schedule">Release 5.0.1</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/03/31/release-6-0">bs-platform release v6.0+dev</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/03/21/release-5-0">bs-platform release v5</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/05/21/ffi-overview">A high level overview of BuckleScript interop with Javascript</a></h1><p class="post-meta">May 21, 2019</p><div class="authorBlock"></div></header><div><span><p>When users start to use BuckleScript to develop applications on JS platform, they have to interop with various APIs provided by the JS platform.</p>
<p>In theory, like <a href="https://elm-lang.org/">Elm</a>, BuckleScript could ship a comprehensive library which contains what most people would like to use daily.
This, however, is particularly challenging, given that
JS is running on so many platforms for example, <a href="https://electronjs.org/">Electron</a>, <a href="https://nodejs.org/">Node</a> and Browser, yet each platform is still evolving quickly. So we have to provide a mechanism to allow users to bind to the native JS API quickly in userland.</p>
<p>There are lots of trade-off when designing such a FFI bridge between OCaml and the JavaScript API. Below, we list a few key items which we think have an important impact on our design.</p>
<h2><a class="anchor" aria-hidden="true" id="interop-design-constraints"></a><a href="#interop-design-constraints" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop design constraints</h2>
<ul>
<li><p>BuckleScript is still OCaml</p>
<p>We are not inventing a new language. In particular, we can not change the concrete syntax of OCaml. Luckily, OCaml introduced <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec260">attributes</a> and <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec262">extension nodes</a> since 4.02, which allows us to customize the language to a minor extent. To be a good citizen in the OCaml community, all attributes introduced by BuckleScript are prefixed with <code>bs</code>.</p></li>
<li><p>Bare metal efficiency should always be possible for experts in pure OCaml</p>
<p>Efficiency is at the heart of BuckleScript's design philosophy, in terms of both compilation speed and runtime performance. While there were other strongly typed functional languages running on the JS platform before we made BuckleScript, one thing in particular that confused me was that in those languages, people have to write <code>native JS</code> to gain performance. Our goal is that when performance really matters, it is still possible for experts to write pure OCaml without digging into <code>native JS</code>, so users don't have to make a choice between performance and type safety.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="easy-interop-using-raw-js"></a><a href="#easy-interop-using-raw-js" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Easy interop using raw JS</h2>
<p>BuckleScript allows users to insert raw JS using extension nodes directly. Please refer to the <a href="https://bucklescript.github.io/docs/en/embed-raw-javascript">documentation</a> for details. Here we only talk about one of the most used styles: inserting raw JS code as a function.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> getSafe : <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span>%raw a b -&gt; {| 
    <span class="hljs-keyword">if</span> (b&gt;=<span class="hljs-number">0</span> &amp;&amp; b &lt; a.length) {
        return a [b]
     }
     throw <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"out of range"</span>)
  |} 

<span class="hljs-keyword">let</span> v = getSafe [|<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>|] (-<span class="hljs-number">1</span>)
</code></pre>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> getSafe: (array(int), int) =&gt; int = <span class="hljs-attribute">[%raw
  (a, b) =&gt; {|
    if (b&gt;=0 &amp;&amp; b &lt; a.length) {
        return a [b]</span>
     }
     throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error</span>(<span class="hljs-string">"out of range"</span>)
  |}
<span class="hljs-literal">]</span>;

<span class="hljs-keyword">let</span> v = <span class="hljs-literal">[|</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><span class="hljs-literal">|]</span><span class="hljs-operator">-&gt;</span>getSafe<span class="hljs-number">(-1)</span>;
</code></pre>
<p>Here the raw extension node asks the user to list the parameters and function statement in raw JS syntax. The generated JS code is as follows:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSafe</span> (<span class="hljs-params">a,b</span>)</span>{ 
    <span class="hljs-keyword">if</span> (b&gt;=<span class="hljs-number">0</span> &amp;&amp; b &lt; a.length) {
        <span class="hljs-keyword">return</span> a [b]
     }
     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"out of range"</span>)
  };

<span class="hljs-keyword">var</span> v = getSafe(<span class="hljs-comment">/* array */</span>[
      <span class="hljs-number">1</span>,
      <span class="hljs-number">2</span>,
      <span class="hljs-number">3</span>
    ], <span class="hljs-number">-1</span>);

</code></pre>
<p>Inserting raw JS code as a function has several advantages:</p>
<ul>
<li>It is relatively safe; there is no variable name polluting.</li>
<li>It is quite expressive since the user can express everything inside the function body.</li>
<li>The compiler still has some knowledge about the function, for example, its arity.</li>
</ul>
<p>Some advice about using this style:</p>
<ul>
<li>Always annotate the raw function with explicit type annotation.</li>
<li>When annotating raw JS, you can use polymorphic types, but don’t create them when you don’t really need them. In general, non polymoprhic type is safer and more efficient.</li>
<li>Write a unit test for the function.</li>
</ul>
<p>Note that a nice thing about this mechanism is that no separate JS file is needed, so no change to the build system is necessary in most cases. By using this mechanism, BuckleScript users can already deal with most bindings.</p>
<h2><a class="anchor" aria-hidden="true" id="interop-via-attributes"></a><a href="#interop-via-attributes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop via attributes</h2>
<p>If you are a developer busy shipping, the mechanism above should cover almost everything you need. A minor disadvange of that mechanism is that it comes with a cost: a raw function can not be inlined since it is JavaScript, so the BuckleScript compiler does not have a deep knowledge about the function.</p>
<p>To demonstrate interop via attributes, we are going to show a small example of binding to JS <code>date</code>. There are lots of advanced topics in the <a href="https://bucklescript.github.io/docs/en/interop-overview">documentation</a>; here we are only talking about one of the most-used methods for interop.</p>
<p>The key idea is to bind your JS object as <a href="https://en.wikipedia.org/wiki/Abstract_data_type">an abstract data type</a> where a data type is defined by its behavior from the point of view of a user of the data, instead of the data type’s concrete representations.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> date
<span class="hljs-keyword">external</span> fromFloat : <span class="hljs-built_in">float</span> -&gt; date = <span class="hljs-string">"Date"</span> [@@bs.<span class="hljs-keyword">new</span>]
<span class="hljs-keyword">external</span> getDate : date -&gt; <span class="hljs-built_in">float</span> = <span class="hljs-string">"getDate"</span> [@@bs.send]
<span class="hljs-keyword">external</span> setDate : date -&gt; <span class="hljs-built_in">float</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"setDate"</span> [@@bs.send]

<span class="hljs-keyword">let</span> date = fromFloat <span class="hljs-number">10000.</span>
<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = setDate date <span class="hljs-number">3.</span>
<span class="hljs-keyword">let</span> d = getDate date
</code></pre>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> date;

[@bs.<span class="hljs-keyword">new</span>]
<span class="hljs-keyword">external</span> fromFloat : <span class="hljs-built_in">float</span> =&gt; date = <span class="hljs-string">"Date"</span> ;
[@bs.send]
<span class="hljs-keyword">external</span> getDate : date =&gt; <span class="hljs-built_in">float</span> = <span class="hljs-string">"getDate"</span> ;
[@bs.send]
<span class="hljs-keyword">external</span> setDate : date =&gt; <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"setDate"</span>;

<span class="hljs-keyword">let</span> date = fromFloat (<span class="hljs-number">10000.0</span>);
date-&gt;setDate (<span class="hljs-number">3.0</span>);
<span class="hljs-keyword">let</span> d = date -&gt; getDate;
</code></pre>
<p>The preceding code generates the following JS. As you can see, the binding itself is zero cost and serves as formal documentation.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">10000</span>);
date.setDate(<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> d = date.getDate();
</code></pre>
<p>A typical workflow is that we create an abstract data type, create bindings for a “maker” using <code>bs.new</code>, and bind methods using <code>bs.send</code>.</p>
<p>Thanks to native support of abstract data types in OCaml, the interop is easy to reason about.</p>
<p>Some advice when using this style:</p>
<ul>
<li>Again, you can use polymorphic types in your annotations, but don't create polymorphic types when you don't need them.</li>
<li>Write a unit test for each external.</li>
</ul>
<p>As a comparison, we can create the same binding using <code>raw</code>:</p>
<pre><code class="hljs css language-ocaml">type date
let fromFloat : float -&gt; date = fun%raw d -&gt; {|return new Date(d)|}
let getDate : date -&gt; float = fun%raw d -&gt; {|return d.getDate()|}
let setDate : date -&gt; float -&gt; unit = fun%raw d v -&gt; {|
   d.setDate(v);
   return 0; // ocaml representation of unit 
|}

let date = fromFloat 10000.
let () = setDate date 3.
let d = getDate date
</code></pre>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> date;
<span class="hljs-keyword">let</span> fromFloat: float =&gt; date = <span class="hljs-attribute">[%raw d =&gt; {|return new Date(d)|}]</span>;
<span class="hljs-keyword">let</span> getDate: date =&gt; float = <span class="hljs-attribute">[%raw d =&gt; {|return d.getDate()|}]</span>;
<span class="hljs-keyword">let</span> setDate: (date, float) =&gt; unit = <span class="hljs-attribute">[%raw
  (d, v) =&gt; {|
   d.setDate(v);
   return 0; // ocaml representation of unit
|}
]</span>;

<span class="hljs-keyword">let</span> date = fromFloat(<span class="hljs-number">10000.</span>);
date<span class="hljs-operator">-&gt;</span>setDate( <span class="hljs-number">3.</span>);
<span class="hljs-keyword">let</span> d = date<span class="hljs-operator">-&gt;</span>getDate;

</code></pre>
<p>The generated JS is as follows, and you can see the cost:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromFloat</span> (<span class="hljs-params">d</span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(d)};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span> (<span class="hljs-params">d</span>)</span>{<span class="hljs-keyword">return</span> d.getDate()};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDate</span> (<span class="hljs-params">d,v</span>)</span>{
   d.setDate(v);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// ocaml representation of unit </span>
};

<span class="hljs-keyword">var</span> date = fromFloat(<span class="hljs-number">10000</span>);

setDate(date, <span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> d = getDate(date);
</code></pre>
<!-- ,  and provide various methods over such abstract data type. -->
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog">Recent Posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#interop-design-constraints">Interop design constraints</a></li><li><a href="#easy-interop-using-raw-js">Easy interop using raw JS</a></li><li><a href="#interop-via-attributes">Interop via attributes</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>